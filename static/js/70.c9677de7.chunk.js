(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{1196:function(e,t,n){},1347:function(e,t,n){"use strict";n.r(t);var a=n(6),s=n(0),r=n.n(s),o=n(180),i=n(4),l=n(16),c=n(24),m=n(617),d=n(33),u=n(51),h=n(12),p=n(31),g=n(7),E=n(46),f=function(e){var t=e.children;return r.a.createElement("code",{className:"P"},t)},_=[{name:"useIsMounted",description:r.a.createElement(r.a.Fragment,null,"If I'm using any async code, I make sure to check if my component is still mounted before doing anything like updating its state."),code:"export const useIsMounted = () => {\n  const isMounted = useRef(false)\n  useEffect(() => {\n      isMounted.current = true\n      return () => isMounted.current = false\n  }, [])\n  return isMounted\n}"},{name:"useIsInView",description:r.a.createElement(r.a.Fragment,null,"For triggering animations that start when a user scrolls to an element. I used this a lot for the ",r.a.createElement(h.a,{to:"https://parse.ly"},"parse.ly")," marketing site."),code:'const useIsInView = (margin="0px") => {\n  const [isIntersecting, setIntersecting] = useState(false)\n  const ref = useRef()\n\n  useEffect(() => {\n    const observer = new IntersectionObserver(([ entry ]) => {\n      setIntersecting(entry.isIntersecting)\n    }, { rootMargin: margin })\n    if (ref.current) observer.observe(ref.current)\n    return () => {\n      observer.unobserve(ref.current)\n    }\n  }, [])\n\n  return [ref, isIntersecting]\n}'},{name:"useHash",description:r.a.createElement(r.a.Fragment,null,"For keeping the ",r.a.createElement("b",null,"hash")," of the url in-sync with a local variable. This is helpful for storing, for example, a filtered view of a chart in the url, so that a visitor can share that specific view."),code:"const useHash = (initialValue=null) => {\n  const [storedValue, setStoredValue] = useState(() => {\n    try {\n      const item = window.location.hash\n      return item ? item.slice(1) : initialValue\n    } catch (error) {\n      console.log(error)\n      return initialValue\n    }\n  })\n\n  const setValue = value => {\n    try {\n      setStoredValue(value)\n      history.pushState(null, null, `#${value}`)\n    } catch (error) {\n      console.log(error)\n    }\n  }\n\n  return [storedValue, setValue]\n}"},{name:"useLocalStorage",description:r.a.createElement(r.a.Fragment,null,"For keeping a ",r.a.createElement(h.a,{to:"https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage"},"localStorage")," value in-sync with a local variable."),url:"https://usehooks.com/useLocalStorage/"},{name:"useInterval",description:r.a.createElement(r.a.Fragment,null,"Especially useful for animations, or anything that needs to loop. Dan Abramov's blog post on this (linked) is especially great for understanding some gotchas with creating custom hooks."),url:"https://overreacted.io/making-setinterval-declarative-with-react-hooks/"},{name:"useCookie",description:r.a.createElement(r.a.Fragment,null,"This seriously make getting & setting cookies a breeze. The only issue, at the moment, is that the hook value doesn't update when you ",r.a.createElement(f,null,"set")," it -- but this should be updated in the future."),url:"https://github.com/reactivestack/cookies/tree/master/packages/react-cookie/"},{name:"useOnKeyPress",description:r.a.createElement(r.a.Fragment,null,"For triggering code when the user presses a specific key. The ",r.a.createElement(f,null,"isDebugging")," variable is optional, but I find it helpful for figuring out the exact value for a key that I need to listen for."),code:'const useOnKeyPress = (targetKey, onKeyDown, onKeyUp, isDebugging=false) => {\n  const [isKeyDown, setIsKeyDown] = useState(false)\n\n  const onKeyDownLocal = useCallback(e => {\n    if (isDebugging) console.log("key down", e.key, e.key != targetKey ? "- isn\'t triggered" : "- is triggered")\n    if (e.key != targetKey) return\n    setIsKeyDown(true)\n\n    if (typeof onKeyDown != "function") return\n    onKeyDown(e)\n  })\n  const onKeyUpLocal = useCallback(e => {\n    if (isDebugging) console.log("key up", e.key, e.key != targetKey ? "- isn\'t triggered" : "- is triggered")\n    if (e.key != targetKey) return\n    setIsKeyDown(false)\n\n    if (typeof onKeyUp != "function") return\n    onKeyUp(e)\n  })\n\n  useEffect(() => {\n    addEventListener(\'keydown\', onKeyDownLocal)\n    addEventListener(\'keyup\', onKeyUpLocal)\n\n    return () => {\n      removeEventListener(\'keydown\', onKeyDownLocal)\n      removeEventListener(\'keyup\', onKeyUpLocal)\n    }\n  }, [])\n\n  return isKeyDown\n}'},{name:"useChartDimensions",description:r.a.createElement(r.a.Fragment,null,"This one is especially helpful! The way ",r.a.createElement(f,null,"<svg>")," elements scale can be tricky, as well as maintaining consistent margin widths for a chart, so this helps me keep charts responsive, and automatically updates any ",r.a.createElement(f,null,"dimensions")," when the window is resized."),code:"const combineChartDimensions = dimensions => {\n  let parsedDimensions = {\n      marginTop: 40,\n      marginRight: 30,\n      marginBottom: 40,\n      marginLeft: 75,\n      ...dimensions,\n  }\n\n  return {\n      ...parsedDimensions,\n      boundedHeight: Math.max(parsedDimensions.height - parsedDimensions.marginTop - parsedDimensions.marginBottom, 0),\n      boundedWidth: Math.max(parsedDimensions.width - parsedDimensions.marginLeft - parsedDimensions.marginRight, 0),\n  }\n}\n\nexport const useChartDimensions = passedSettings => {\n  const ref = useRef()\n  const dimensions = combineChartDimensions(passedSettings)\n\n  const [width, changeWidth] = useState(0)\n  const [height, changeHeight] = useState(0)\n\n  useEffect(() => {\n    if (dimensions.width && dimensions.height) return\n\n    const element = ref.current\n    const resizeObserver = new ResizeObserver(entries => {\n      if (!Array.isArray(entries)) return\n      if (!entries.length) return\n\n      const entry = entries[0]\n\n      if (width != entry.contentRect.width) changeWidth(entry.contentRect.width)\n      if (height != entry.contentRect.height) changeHeight(entry.contentRect.height)\n    })\n\n    resizeObserver.observe(element)\n\n    return () => resizeObserver.unobserve(element)\n  }, [])\n\n  const newSettings = combineChartDimensions({\n    ...dimensions,\n    width: dimensions.width || width,\n    height: dimensions.height || height,\n  })\n\n  return [ref, newSettings]\n}"}],y=[[{description:r.a.createElement("p",null,"With class components, we tie updates to specific ",r.a.createElement("b",null,"lifecycle events"),"."),code:'class Chart extends Component {\n  componentDidMount() {\n    // when Chart mounts, do this\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.data == props.data) return\n    // when data updates, do this\n  }\n\n  componentWillUnmount() {\n    // before Chart unmounts, do this\n  }\n\n  render() {\n    return (\n      <svg className="Chart" />\n    )\n  }\n}',highlightedLines:[2,3,4,6,7,8,9,11,12,13],markers:[[2,3,4],[6,7,8,9],[11,12,13]]},{description:r.a.createElement("p",null,"In a function component, we instead use the ",r.a.createElement(f,null,"useEffect")," hook to run code during the major ",r.a.createElement("b",null,"lifecycle events"),"."),code:'const Chart = ({ data }) => {\n  useEffect(() => {\n    // when Chart mounts, do this\n    // when data updates, do this\n\n    return () => {\n      // when data updates, do this\n      // before Chart unmounts, do this\n    }\n  }, [data])\n\n  return (\n    <svg className="Chart" />\n  )\n}',highlightedLines:[3,4,6,7,8,9],markers:[[3],[4,7],[8]]}],[{description:r.a.createElement(r.a.Fragment,null,r.a.createElement("p",null,"With ",r.a.createElement("b",null,"lifecycle events"),", we need to deal with all changes in one spot. Our thinking looks something like:",r.a.createElement("blockquote",null,"When our component loads, and when props change (specifically ",r.a.createElement(f,null,"dateRange"),"), update ",r.a.createElement(f,null,"data")))),code:'class Chart extends Component {\n  state = {\n    data: null,\n  }\n\n  componentDidMount() {\n    const newData = getDataWithinRange(this.props.dateRange)\n    this.setState({data: newData})\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.dateRange != this.props.dateRange) {\n      const newData = getDataWithinRange(this.props.dateRange)\n      this.setState({data: newData})\n    }\n  }\n\n  render() {\n    return (\n      <svg className="Chart" />\n    )\n  }\n}',highlightedLines:[6,7,8,9,11,12,13,14,15,16],markers:[[6,7,8,9,11,12,13,14,15,16]]},{description:r.a.createElement("p",null,"In a function component, we need to think about ",r.a.createElement("b",null,"what values stay in-sync"),". Each update flows more like the statement:",r.a.createElement("blockquote",null,"Keep ",r.a.createElement(f,null,"data")," in sync with ",r.a.createElement(f,null,"dateRange"))),code:'const Chart = ({ dateRange }) => {\n  const [data, setData] = useState()\n\n  useEffect(() => {\n    const newData = getDataWithinRange(dateRange)\n    setData(newData)\n  }, [dateRange])\n\n  return (\n    <svg className="Chart" />\n  )\n}',highlightedLines:[4,5,6,7],markers:[[4,5,6,7]],afterCodeText:r.a.createElement(r.a.Fragment,null,r.a.createElement(E.a,null,"Let's pretend that we're either defining ",r.a.createElement(f,null,"getDataWithinRange()")," outside of the component, or substituting it for inline code that generates the ",r.a.createElement(f,null,"newData"),". For this simple example, we'll skip that definition so we can focus on the concepts."))}],[{description:r.a.createElement("p",null),code:'class Chart extends Component {\n  state = {\n    data: null,\n  }\n\n  componentDidMount() {\n    const newData = getDataWithinRange(this.props.dateRange)\n    this.setState({data: newData})\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.dateRange != this.props.dateRange) {\n    const newData = getDataWithinRange(this.props.dateRange)\n      this.setState({data: newData})\n    }\n  }\n\n  render() {\n    return (\n      <svg className="Chart" />\n    )\n  }\n}',markers:[[6,7,8,9,11,12,13,14,15,16]]},{description:r.a.createElement(r.a.Fragment,null,r.a.createElement("p",null,"In fact, this last example was still thinking inside the class-component box. We're storing ",r.a.createElement(f,null,"data")," in ",r.a.createElement(f,null,"state")," to prevent re-calculating it every time our component updates."),r.a.createElement("p",null,"But we no longer need to use ",r.a.createElement(f,null,"state"),"! Here to the rescue is ",r.a.createElement(h.a,{to:"https://reactjs.org/docs/hooks-reference.html#usememo"},r.a.createElement(f,null,"useMemo()")),", which will only re-calculate ",r.a.createElement(f,null,"data")," when its ",r.a.createElement("b",null,"dependency array")," changes.")),code:'const Chart = ({ dateRange }) => {\n  const data = useMemo(() => (\n    getDataWithinRange(dateRange)\n  ), [dateRange])\n\n  return (\n    <svg className="Chart" />\n  )\n}',highlightedLines:[2,3,4],markers:[[2,3,4]],afterCodeText:r.a.createElement(r.a.Fragment,null,r.a.createElement(E.a,null,r.a.createElement("p",null,"Note that we can always just define variables right inside of our function."),r.a.createElement(c.a,{highlightedLines:[2],hasLineNumbers:!1,doWrap:!1},'const Chart = ({ dateRange }) => {\n  const newData = getDataWithinRange(dateRange)\n\n  return (\n    <svg className="Chart" />\n  )\n}'),r.a.createElement("p",null,"This works just fine, unless our ",r.a.createElement(f,null,"getDataWithinRange()")," function is ",r.a.createElement("b",null,"computationally expensive"),". I use ",r.a.createElement(f,null,"useMemo()")," a lot, especially when handling large datasets, to keep things speedy.")))}],[{description:r.a.createElement(r.a.Fragment,null,r.a.createElement("p",null,"Imagine that we have many values that we need to calculate, but they depend on different ",r.a.createElement(f,null,"props"),". For example, we need to calculate:"),r.a.createElement(u.a,{items:[r.a.createElement(r.a.Fragment,null,"our ",r.a.createElement(f,null,"data")," when our ",r.a.createElement(f,null,"dateRange")," changes,"),r.a.createElement(r.a.Fragment,null,"the ",r.a.createElement(f,null,"dimensions")," of a chart when the ",r.a.createElement(f,null,"margins")," change, and"),r.a.createElement(r.a.Fragment,null,"our ",r.a.createElement(f,null,"scales")," when our ",r.a.createElement(f,null,"data")," changes")]})),code:'class Chart extends Component {\n  state = {\n    data: null,\n    dimensions: null,\n    xScale: null,\n    yScale: null,\n  }\n\n  componentDidMount() {\n    const newData = getDataWithinRange(this.props.dateRange)\n    this.setState({data: newData})\n    this.setState({dimensions: getDimensions()})\n    this.setState({xScale: getXScale()})\n    this.setState({yScale: getYScale()})\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    if (prevProps.dateRange != this.props.dateRange) {\n      const newData = getDataWithinRange(this.props.dateRange)\n      this.setState({data: newData})\n    }\n    if (prevProps.margins != this.props.margins) {\n      this.setState({dimensions: getDimensions()})\n    }\n    if (prevState.data != this.state.data) {\n      this.setState({xScale: getXScale()})\n      this.setState({yScale: getYScale()})\n    }\n  }\n\n  render() {\n    return (\n      <svg className="Chart" />\n    )\n  }\n}',highlightedLines:[9,10,11,12,13,14,15].concat(Object(g.a)(Object(i.range)(17,30))),markers:[[10,11,17,18,19,20],[12,23],[13,26],[14,27]]},{description:r.a.createElement(r.a.Fragment,null,r.a.createElement("p",null,"In our function component, we can focus on our simple statements, like:"),r.a.createElement("blockquote",null,"Keep ",r.a.createElement(f,null,"dimensions")," in sync with ",r.a.createElement(f,null,"margins"))),code:'const Chart = ({ dateRange, margins }) => {\n  const data = useMemo(() => (\n    getDataWithinRange(dateRange)\n  ), [dateRange])\n  const dimensions = useMemo(getDimensions, [margins])\n  const xScale = useMemo(getXScale, [data])\n  const yScale = useMemo(getYScale, [data])\n\n  return (\n    <svg className="Chart" />\n  )\n}',highlightedLines:[2,3,4,5,6,7],markers:[[2,3,4],[5],[6],[7]],afterCodeText:r.a.createElement(r.a.Fragment,null,r.a.createElement("p",null,"See how unwieldy our ",r.a.createElement("b",null,"class component")," got, even in our simple example?"),r.a.createElement("p",null,"This is because we had a lot of declarative code explaining ",r.a.createElement("b",null,"how")," keep our variables in-sync with ",r.a.createElement(f,null,"props")," and ",r.a.createElement(f,null,"state"),", and in our ",r.a.createElement("b",null,"function component"),", we get to focus only on ",r.a.createElement("b",null,"what")," to keep in-sync."),r.a.createElement("p",null,"Notice how we can use as many ",r.a.createElement(f,null,"useMemo()")," hooks as we want - letting us keep the ",r.a.createElement("b",null,"dependencies")," and ",r.a.createElement("b",null,"effects")," as close as possible."))}],[{description:r.a.createElement(r.a.Fragment,null,r.a.createElement("p",null,"In our class component, we'll need to compare our ",r.a.createElement(f,null,"prevState")," and current ",r.a.createElement(f,null,"state"),".")),code:'class Chart extends Component {\n  state = {\n    data: null,\n    dimensions: null,\n    xScale: null,\n    yScale: null,\n  }\n\n  componentDidMount() {\n    const newData = getDataWithinRange(this.props.dateRange)\n    this.setState({data: newData})\n    this.setState({dimensions: getDimensions()})\n    this.setState({xScale: getXScale()})\n    this.setState({yScale: getYScale()})\n  }\n\n  componentDidUpdate(prevProps, prevState) {\n    if (prevProps.dateRange != this.props.dateRange) {\n      const newData = getDataWithinRange(this.props.dateRange)\n      this.setState({data: newData})\n    }\n    if (prevProps.margins != this.props.margins) {\n      this.setState({dimensions: getDimensions()})\n    }\n    if (\n      prevState.data != this.state.data\n      || prevState.dimensions != this.state.dimensions\n    ) {\n      this.setState({xScale: getXScale()})\n      this.setState({yScale: getYScale()})\n    }\n  }\n\n  render() {\n    return (\n      <svg className="Chart" />\n    )\n  }\n}',highlightedLines:[27],markers:[[10,11,18,19,20,21],[12,23],[13,29],[14,30]]},{description:r.a.createElement("p",null,"Our hooks' ",r.a.createElement("b",null,"dependency arrays")," don't care whether our ",r.a.createElement(f,null,"margins")," or ",r.a.createElement(f,null,"dimensions")," are in our ",r.a.createElement(f,null,"props"),", ",r.a.createElement(f,null,"state"),", or neither - a value is a value, as far as they're concerned."),code:'const Chart = ({ dateRange, margins }) => {\n  const data = useMemo(() => (\n    getDataWithinRange(dateRange)\n  ), [dateRange])\n  const dimensions = useMemo(getDimensions, [margins])\n  const xScale = useMemo(getXScale, [data, dimensions])\n  const yScale = useMemo(getYScale, [data, dimensions])\n\n  return (\n    <svg className="Chart" />\n  )\n}',highlightedLines:[6,7],markers:[[2,3,4],[5],[6],[7]]}]],w=n(266),v=n.n(w),k=(n(1196),_.sort(function(e,t){return t.code?1:-1})),b=Object(i.mean)(y.map(function(e){return e[1].code.split("\n").length/e[0].code.split("\n").length})),S=(t.default=function(){return r.a.createElement("div",{className:"Hooks"},r.a.createElement(o.Helmet,null,r.a.createElement("meta",{charSet:"utf-8"}),r.a.createElement("title",null,"Thinking in React Hooks"),r.a.createElement("link",{rel:"canonical",href:"https://wattenberger.com/blog/react-hooks"}),r.a.createElement("meta",{property:"og:type",content:"website"}),r.a.createElement("meta",{name:"description",content:"React introduced hooks one year ago, and they've been a game-changer for a lot of developers. There are tons of how-to introduction resources out there, but I want to talk about the fundamental mindset change when switching from React class components to function components + hooks."}),r.a.createElement("meta",{name:"image",content:v.a})),r.a.createElement("h1",null,"Thinking in React Hooks"),r.a.createElement("div",{className:"Hooks__content"},r.a.createElement("p",null,"React introduced hooks one year ago, and they've been a game-changer for a lot of developers. There are tons of how-to introduction resources out there, but I want to talk about the ",r.a.createElement("b",null,"fundamental mindset change")," when switching from React class components to function components + hooks."),r.a.createElement(C,{sides:y[0]}),r.a.createElement("p",null,"Great! At this point, you might be thinking:"),r.a.createElement(I,null),r.a.createElement("p",null,"but that's the ",r.a.createElement("b",{className:"a3"},"wrong")," way to look at it."),r.a.createElement("p",null,"Hmm, let's look at a concrete example to see what the difference is. For example, what if we have a ",r.a.createElement("b",null,"computationally expensive")," ",r.a.createElement(f,null,"getDataWithinRange()")," function that returns a filtered dataset, based on a specified ",r.a.createElement(f,null,"dateRange"),"? Because ",r.a.createElement(f,null,"getDataWithinRange()")," takes some time to run, we'll want to store it in our component's ",r.a.createElement(f,null,"state")," object and only update it when ",r.a.createElement(f,null,"dateRange")," changes."),r.a.createElement(C,{sides:y[1]}),r.a.createElement("p",null,"See how much easier it is to wrap your head around the concept of ",r.a.createElement("b",null,"keeping variables in-sync"),"?"),r.a.createElement(C,{sides:y[2]}),r.a.createElement("h2",null,"Thinking about updates in-context"),r.a.createElement("p",null,"Not impressed yet? Fine.",r.a.createElement("br",null),"Here is where this concept really shines."),r.a.createElement(C,{sides:y[3]}),r.a.createElement("h2",null,"Looser definition of ",r.a.createElement(f,null,"state")),r.a.createElement("p",null,"Okay! Moving on -- what if our ",r.a.createElement(f,null,"scales")," needed to change based on the ",r.a.createElement(f,null,"dimensions")," of our chart?"),r.a.createElement(C,{sides:y[4]}),r.a.createElement("h2",null,"Keeping code concise"),r.a.createElement("p",null,"Shorter code isn't necessarily easier to read, but keeping our components as clutter-free as possible is definitely a win!"),r.a.createElement("p",null,"Let's quickly compare the length of the examples we've just read:"),r.a.createElement("div",{className:"Hooks__code-examples"},y.map(function(e,t){return r.a.createElement("div",{className:"Hooks__code-examples__item",key:t},e.map(function(e,t){var n=e.code;return e.markers,r.a.createElement("div",{className:"Hooks__code-examples__item__code",key:t,style:{height:"".concat(.5*n.split("\n").length,"em")}},r.a.createElement("div",{className:"Hooks__code-examples__item__code__text"},n.split("\n").length," lines"))}))})),r.a.createElement("p",null,"Hey! Our ",r.a.createElement("b",null,"function components")," are, on average, ",r.a.createElement("b",null,Object(i.format)(".1%")(b))," of the length of their ",r.a.createElement("b",null,"class component")," counterparts."),r.a.createElement("p",null,"Additionally, let's highlight each of the code changes across the two versions:"),r.a.createElement("div",{className:"Hooks__code-examples"},y.map(function(e,t){return r.a.createElement("div",{className:"Hooks__code-examples__item",key:t},e.map(function(e,t){var n=e.code,a=e.markers;return r.a.createElement("div",{className:"Hooks__code-examples__item__code",key:t,style:{height:"".concat(.5*n.split("\n").length,"em")}},r.a.createElement("div",{className:"Hooks__code-examples__item__code__text"},n.split("\n").length," lines"),a.map(function(e,t){return e.map(function(e){return r.a.createElement("div",{className:"Hooks__code-examples__item__code__marker",key:e,style:{background:x[t][1],top:"".concat(.5*e,"em")}})})}))}))})),r.a.createElement("p",null,"We can see how we're keeping each concern separate from its friends - grouping by concern instead of by lifecycle event."),r.a.createElement("h2",null,"Sharing more complex functionality"),r.a.createElement("p",null,"We've always had the ability to share utility functions between components, but they never had access to the components' lifecycle events. Sure, we had tricks like ",r.a.createElement(h.a,{to:"https://reactjs.org/docs/higher-order-components.html"},"Higher-Order Components"),", but they often felt like more trouble than they were worth, and cluttered up our ",r.a.createElement(f,null,"render")," functions."),r.a.createElement("p",null,"In every project I'm currently working on, I have a library of simple hooks that just make my life easier. In my experience, the main benefits of being able to share complex code are:"),r.a.createElement(u.a,{items:[r.a.createElement(r.a.Fragment,null,"not having to re-write common patterns like keeping svg ",r.a.createElement(f,null,"dimensions")," in-sync with a wrapper element. This one especially was ",r.a.createElement("b",null,"lots")," of code that was a pain to replicate for every chart"),r.a.createElement(r.a.Fragment,null,"KISS - letting me think through each pattern ",r.a.createElement("b",null,"one time"),", ensuring that I didn't miss anything like cleaning up an event listener")]}),r.a.createElement("p",null,"Okay, Amelia, I get it. Let's get to the meat of the matter - here is ",r.a.createElement("b",null,"a collection of hooks")," that I've been really appreciating these days."),r.a.createElement("h2",null,"Custom hooks that I \u2665"),r.a.createElement("div",{className:"Hooks__examples"},k.map(function(e){var t=e.name,n=e.description,a=e.code,s=e.url;return a?r.a.createElement(m.a,{key:t,className:"Hooks__examples__item",trigger:r.a.createElement("div",{className:"Hooks__examples__item__trigger"},r.a.createElement("div",{className:"Hooks__examples__item__name"},t),r.a.createElement("div",{className:"Hooks__examples__item__description"},n)),triggerExpandText:"show me the code"},r.a.createElement(c.a,{fileName:t,size:"s"},a)):r.a.createElement(h.a,{to:s,className:"Hooks__examples__item Hooks__examples__item--link",key:t},r.a.createElement("div",{className:"Hooks__examples__item__trigger"},r.a.createElement("div",{className:"Hooks__examples__item__name"},t),r.a.createElement("div",{className:"Hooks__examples__item__description"},n),r.a.createElement("div",{className:"Hooks__examples__item__link"},L(s))),r.a.createElement(d.a,{name:"arrow",direction:"e"}))})),r.a.createElement("h2",null,"More learnings about React Hooks"),r.a.createElement("div",{className:"Hooks__resources"},M.map(function(e){var t=e.name,n=e.description,a=e.url;return r.a.createElement(h.a,{to:a,className:"Hooks__resources__item",key:t},r.a.createElement("div",{className:"Hooks__resources__item__trigger"},r.a.createElement("div",{className:"Hooks__resources__item__name"},t),r.a.createElement("div",{className:"Hooks__resources__item__description"},n),r.a.createElement("div",{className:"Hooks__resources__item__link"},L(a))),r.a.createElement(d.a,{name:"arrow",direction:"e"}))}))))},["Class component","Function component"]),C=function(e){var t=e.sides;return r.a.createElement("div",{className:"SideBySide SideBySide--is-".concat(t.filter(function(e){return e.afterCodeText}).length>0?"inline":"stretched")},r.a.createElement("div",{className:"SideBySide__section SideBySide__titles"},t.map(function(e,t){var n=e.name;return r.a.createElement("h6",{className:"desktop SideBySide__section__item SideBySide__titles__item",key:t},n||S[t])})),r.a.createElement("div",{className:"SideBySide__section SideBySide__descriptions"},t.map(function(e,t){var n=e.description;return r.a.createElement("div",{className:"desktop SideBySide__section__item SideBySide__descriptions__item",key:t},n)})),r.a.createElement("div",{className:"SideBySide__section SideBySide__code"},t.map(function(e,n){var a=e.name,s=e.description,o=e.code,i=e.highlightedLines,l=e.markers,m=e.afterCodeText;return r.a.createElement(r.a.Fragment,null,r.a.createElement("h6",{className:"mobile SideBySide__titles__item"},a||S[n]),r.a.createElement("div",{className:"mobile SideBySide__descriptions__item"},s),!!n&&r.a.createElement(D,{markers:[t[n-1].markers,l],maxLines:Math.max(o.split("\n").length,t[n-1].code.split("\n").length)}),r.a.createElement("div",{className:"SideBySide__code__item"},r.a.createElement(c.a,Object.assign({key:n,className:"SideBySide__section__item SideBySide__code__item"},{highlightedLines:i},{hasLineNumbers:!1,doWrap:!1}),o),r.a.createElement("div",{className:"SideBySide__after__item"},m)))})))},x=[["#50B7D9","#6668ec"],["#eba117","#e06932"],["#bde06c","#12cba3"],["#e460a2","#983dd4"]],D=function(e){var t=e.markers,n=e.maxLines,o=Object(s.useState)(),i=Object(a.a)(o,2),c=i[0],m=i[1],d=Object(s.useMemo)(function(){return t[0].map(function(e,n){var a=t[1][n];return{firstGroup:e,secondGroup:a,paths:Object(l.flatMap)(e.map(function(e){return Object(l.flatMap)(a.map(function(t){return N(e-1,t-1)}))}))}})},[t,n]),u=Object(s.useMemo)(l.uniqueId,[]);return r.a.createElement("div",{className:"desktop SideBySideCodeMiddle-wrapper"},r.a.createElement("svg",{className:"SideBySideCodeMiddle",viewBox:"0 0 ".concat(1," ").concat(1*n),preserveAspectRatio:"none",height:"".concat(1.8*n,"em")},r.a.createElement("defs",null,x.map(function(e,t){return r.a.createElement("linearGradient",{x1:"0",x2:"100%",id:"middle-".concat(u,"-").concat(t),gradientUnits:"userSpaceOnUse",key:t},r.a.createElement("stop",{stopColor:e[0]}),r.a.createElement("stop",{stopColor:e[1],offset:"100%"}))}),r.a.createElement("clipPath",{id:"".concat(u,"-clip")},r.a.createElement("rect",{width:1,height:1*n}))),d.map(function(e,t){var n=e.paths;e.firstGroup,e.secondGroup;return r.a.createElement("g",{className:["SideBySideCodeMiddle__group","SideBySideCodeMiddle__group--is-".concat(c==t?"hovering":Number.isFinite(c)?"hovering-other":"normal")].join(" "),key:t,style:{clipPath:"url(#".concat(u,"-clip)")},fill:"url(#middle-".concat(u,"-").concat(t,")"),onMouseEnter:function(){return m(t)},onMouseLeave:function(){return m(null)}},n.map(function(e,n){return r.a.createElement("path",{className:"SideBySideCodeMiddle__marker SideBySideCodeMiddle__marker--i-".concat(t),d:e})}))})),r.a.createElement("svg",{className:"SideBySideCodeMiddle__highlight",viewBox:"0 0 1 ".concat(1*n),preserveAspectRatio:"none",height:"".concat(1.8*n,"em")},d.map(function(e,t){e.paths;var n=e.firstGroup;e.secondGroup;return r.a.createElement("g",{className:["SideBySideCodeMiddle__highlight__group","SideBySideCodeMiddle__highlight__group--is-".concat(c==t?"hovering":Number.isFinite(c)?"hovering-other":"normal")].join(" "),key:t,style:{clipPath:"url(#".concat(u,"-clip)")},fill:x[t][0]},n.map(function(e,t){return r.a.createElement("rect",{key:t,className:"SideBySideCodeMiddle__highlight__marker",x:0,width:1,y:1*(e-1)-.01,height:1.02})}))})),r.a.createElement("svg",{className:"SideBySideCodeMiddle__highlight SideBySideCodeMiddle__highlight--right",viewBox:"0 0 1 ".concat(1*n),preserveAspectRatio:"none",height:"".concat(1.8*n,"em")},d.map(function(e,t){e.paths,e.firstGroup;var n=e.secondGroup;return r.a.createElement("g",{className:["SideBySideCodeMiddle__highlight__group","SideBySideCodeMiddle__highlight__group--is-".concat(c==t?"hovering":Number.isFinite(c)?"hovering-other":"normal")].join(" "),key:t,style:{clipPath:"url(#".concat(u,"-clip)")},fill:x[t][1]},n.map(function(e,t){return r.a.createElement("rect",{key:t,className:"SideBySideCodeMiddle__highlight__marker",x:0,width:1,y:1*(e-1)-.01,height:1.02})}))})))},N=function(e,t){return R([["M",0,1*e-.01],["L",0,1*e-.01],["C"],[.3,1*e-.01],[.7,1*t-.01],[1,1*t-.01],["L",1,1*(t+1)+.01],["C"],[.7,1*(t+1)+.01],[.3,1*(e+1)+.01],[0,1*(e+1)+.01],["L",0,1*(e+1)+.01],,["Z"]])},R=function(e){return e.map(function(e){return e.join(" ")}).join(" ")},M=[{url:"https://medium.com/@dan_abramov/making-sense-of-react-hooks-fdbde8803889",name:"Making Sense of React Hooks",description:"A great introduction to the concept of hooks and how they're implemented."},{url:"https://tylermcginnis.com/why-react-hooks/",name:"Why React Hooks?",description:"A look at the historical ways to create React components, and some problems that hooks solve."},{url:"https://usehooks.com/",name:"useHooks(\ud83d\udc20)",description:"An awesome resources of custom hooks"},{url:"https://reactjs.org/docs/hooks-overview.html",name:"Hooks at a Glance",description:"An overview of the different types of built-in hooks."},{url:"https://overreacted.io/a-complete-guide-to-useeffect/",name:"A Complete Guide to useEffect",description:"A very in-depth article on hooks-thinking and gotchas."},{url:"https://www.fullstackreact.com/",name:"Fullstack React",description:r.a.createElement(r.a.Fragment,null,"If you like learning from books, I've heard great things about this one. Plus, there is a new chapter on React Hooks, since ",r.a.createElement("b",null,"Newline")," is really good about keeping their books up-to-date.")}],H=Object(i.scaleLinear)().domain([.4,.6]).range([0,1]).clamp(!0),I=function(){var e=Object(s.useState)(!1),t=Object(a.a)(e,2),n=t[0],o=t[1],i=Object(s.useState)(0),l=Object(a.a)(i,2),c=l[0],m=l[1],d=Object(s.useRef)(0);return Object(s.useEffect)(function(){var e=function(){var e=(d.current-window.scrollY)/window.innerHeight,t=e>0?1-e:Math.abs(e),n=H(t);m(n)};return n?(d.current=window.scrollY,window.addEventListener("scroll",e)):window.removeEventListener("scroll",e),function(){window.removeEventListener("scroll",e)}},[n]),r.a.createElement(p.a,{className:"CrossOutQuote",isInViewChange:function(e){o(0==e)},hasIndicator:!1,thresholdPercent:0},r.a.createElement("blockquote",null,r.a.createElement("svg",{className:"CrossOutQuote__scratch",viewBox:"0 0 1770 198",preserveAspectRatio:"none"},r.a.createElement("path",{d:B,style:{strokeDashoffset:"".concat(5e3-5e3*c,"px")}})),"Got it, so ",r.a.createElement(f,null,"useEffect()")," is just a new way to hook into lifecycle events!"))},B="M1 121C22.2555 125.831 38.1827 141.224 60.3333 144.778C86.9413 149.046 115.913 138.373 139 126.222C183.185 102.967 225.056 75.2475 269 51.4444C287.803 41.2594 322.06 28.3653 338.778 48.3333C357.202 70.3399 346.595 99.2786 330 118.444C323.617 125.817 316.62 133.363 308.333 138.667C299.538 144.296 310.363 120.711 311 119.222C324.632 87.3462 359.731 58.8025 395.444 58C435.973 57.0892 441.809 97.9021 437.889 129C435.878 144.953 443.593 134.344 449.667 126.111C468.21 100.979 486.975 75.9876 509.667 54.3333C532.234 32.7971 565.748 6.45343 599.556 14.4444C643.628 24.8614 613.092 99.3831 597.889 123.667C590.618 135.28 572.919 148.393 583.111 124.222C602.214 78.9205 630.983 40.6786 674.111 15.3333C695.592 2.70944 729.074 -10.7168 745 17.4444C764.124 51.2611 752.606 100.751 738.778 134.333C733.629 146.838 726.023 159.873 716.778 169.889C713.467 173.475 714.656 170.425 715.889 167.889C720.492 158.422 726.362 149.521 731.667 140.444C742.219 122.389 752.837 104.632 765.778 88.1111C789.395 57.962 820.652 22.2526 859.222 11.6666C881.849 5.45652 912.181 6.36074 925.444 29.2222C935.559 46.656 932.402 73.3337 929.667 92.1111C926.691 112.533 918.691 130.671 907.889 148.111C898.868 162.674 882.123 193.437 862.889 196.889C852.862 198.689 859.163 177.56 859.778 174.889C866.701 144.799 882.918 117.633 900.778 92.7777C915.117 72.8214 932.56 55.8815 952.778 41.8888C985.708 19.0984 1037.47 -10.4418 1079 4.77774C1130.47 23.6391 1108.4 107.539 1095.22 144.111C1090.57 157.022 1083.97 168.295 1074.33 178.111C1072.01 180.477 1062.32 191.604 1061.44 182.111C1057.52 139.613 1089.64 90.3545 1115.89 60.4444C1135.54 38.0545 1161.75 15.4749 1190.89 6.99996C1226.52 -3.36081 1259.88 13.697 1272.78 48.1111C1283.14 75.7729 1286.83 105.783 1269 131C1267.47 133.169 1224.51 182.019 1222.33 167.889C1220.49 155.899 1227.51 137.452 1231.89 126.556C1241.75 102.029 1258.88 77.3959 1278.67 59.8888C1297.17 43.5125 1321.16 32.3399 1344.67 25.3333C1373.22 16.8233 1394.36 29.2511 1413.44 51C1434.94 75.4993 1431.6 117.459 1419.11 145.556C1410.97 163.876 1410.35 152.19 1414 138C1428 83.483 1478.39 29.2523 1538.78 31C1590.63 32.5004 1609.27 92.0133 1645.56 118.556C1683.35 146.199 1727.06 138.587 1769 129",L=function(){return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:"").split("//").slice(-1)[0].split("/")[0]}},617:function(e,t,n){"use strict";var a=n(6),s=n(34),r=n(0),o=n.n(r),i=n(33),l=n(147);n(129),n(619);t.a=function(e){var t=e.trigger,n=e.triggerExpandText,c=(e.doHideIfCollapsed,e.className),m=e.children,d=Object(s.a)(e,["trigger","triggerExpandText","doHideIfCollapsed","className","children"]),u=Object(r.useState)(!1),h=Object(a.a)(u,2),p=h[0],g=h[1],E=Object(r.useRef)();return o.a.createElement("details",Object.assign({className:"Expandy Expandy--is-".concat(p?"expanded":"collapsed"," ").concat(c)},d,{ref:E,onToggle:function(e){var t=e.target.open;g(t)}}),o.a.createElement("summary",null,o.a.createElement("div",{className:"Expandy__trigger button-no-appearance"},o.a.createElement("div",{className:"Expandy__trigger__text"},o.a.createElement("b",null,t),o.a.createElement("div",{className:"Expandy__trigger__info"},n||"tap me ".concat(p?"to hide":"for more"," details"))),o.a.createElement("div",{className:"Expandy__trigger__mark"},"\u1f30")),o.a.createElement(l.a,{className:"Expandy__toggle",contents:o.a.createElement("button",{className:"button-no-appearance"},p?"Collapse me":"Expand me")},o.a.createElement("div",{className:"Expandy__toggle__arrow Expandy__toggle__arrow--up"},o.a.createElement(i.a,{name:"arrow",direction:"n",size:"s"})),o.a.createElement("div",{className:"Expandy__toggle__arrow Expandy__toggle__arrow--down"},o.a.createElement(i.a,{name:"arrow",direction:"s",size:"s"})))),o.a.createElement("div",{className:"Expandy__contents"},m))}},619:function(e,t,n){}}]);
//# sourceMappingURL=70.c9677de7.chunk.js.map