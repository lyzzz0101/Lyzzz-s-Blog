{"version":3,"sources":["../node_modules/d3-geo-polygon/src/noop.js","../node_modules/d3-geo-polygon/src/pointEqual.js","../node_modules/d3-geo-polygon/src/clip/rejoin.js","../node_modules/d3-geo-polygon/src/math.js","../node_modules/d3-geo-polygon/src/adder.js","../node_modules/d3-geo-polygon/src/cartesian.js","../node_modules/d3-geo-polygon/src/polygonContains.js","../node_modules/d3-geo-polygon/node_modules/d3-array/src/merge.js","../node_modules/d3-geo-polygon/src/clip/index.js","../node_modules/d3-geo-polygon/src/clip/buffer.js","../node_modules/d3-geo-polygon/src/intersect.js","../node_modules/d3-geo-polygon/src/clip/polygon.js","../node_modules/d3-geo-polygon/src/polyhedral/matrix.js","../node_modules/d3-geo-polygon/src/polyhedral/index.js","../node_modules/d3-geo-polygon/src/polyhedral/octahedron.js","../node_modules/d3-geo-polygon/src/polyhedral/butterfly.js","../node_modules/d3-geo-polygon/src/collignon.js","../node_modules/d3-geo-polygon/src/polyhedral/collignon.js","../node_modules/d3-geo-polygon/src/polyhedral/waterman.js","../node_modules/d3-geo-polygon/src/polyhedral/voronoi.js","../node_modules/d3-geo-polygon/src/polyhedral/dodecahedral.js","../node_modules/d3-geo-polygon/node_modules/d3-array/src/ascending.js","../node_modules/d3-geo-polygon/node_modules/d3-array/src/leastIndex.js","../node_modules/d3-geo-polygon/node_modules/d3-array/src/minIndex.js","../node_modules/d3-geo-polygon/node_modules/d3-array/src/scan.js","../node_modules/d3-geo-polygon/src/lagrange.js","../node_modules/d3-geo-polygon/src/complex.js","../node_modules/d3-geo-polygon/src/cox.js","../node_modules/d3-geo-polygon/src/newton.js","../node_modules/d3-geo-polygon/src/tetrahedralLee.js","../node_modules/d3-geo-polygon/src/grayfuller.js","../node_modules/d3-geo-polygon/node_modules/d3-array/src/range.js","../node_modules/d3-geo-polygon/src/airocean.js","../node_modules/d3-geo-polygon/src/icosahedral.js","../node_modules/d3-geo-polygon/src/imago.js","../node_modules/d3-geo-polygon/src/polyhedral/cube.js","../node_modules/d3-geo-polygon/src/cubic.js","../node_modules/d3-geo-polygon/src/cahillKeyes.js","../node_modules/d3-geo-polygon/src/complexLog.js","../node_modules/d3-geo-polygon/src/index.js","../node_modules/react-select/dist/react-select.browser.esm.js"],"names":["noop","pointEqual","a","b","Intersection","point","points","other","entry","this","x","z","o","e","v","n","p","rejoin_link","array","length","i","abs","Math","atan","atan2","cos","ceil","exp","floor","log","max","math_min","min","pow","math_sign","round","sign","sin","tan","epsilon","epsilon2","pi","PI","halfPi","quarterPi","sqrt1_2","SQRT1_2","sqrtPi","sqrt","tau","degrees","radians","asin","acos","Adder","reset","prototype","constructor","s","t","add","y","_add","temp","valueOf","adder","bv","av","cartesian_spherical","cartesian","sphericalDegrees","c","cartesian_cartesian","spherical","lambda","phi","cosPhi","cartesianDegrees","cartesianDot","cartesianCross","cartesianNormalizeInPlace","d","l","cartesianEqual","dx","dy","dz","sum","polygonContains","polygon","normal","angle","winding","m","ring","point0","lambda0","phi0","sinPhi0","cosPhi0","j","lambda1","sinPhi1","cosPhi1","point1","phi1","delta","absDelta","antimeridian","k","arc","intersection","phiArc","_marked","regenerator_default","mark","flatten","arrays","_iterator","_step","wrap","_context","prev","next","Object","createForOfIteratorHelper","done","value","delegateYield","t1","f","finish","stop","src_clip","pointVisible","clipLine","interpolate","start","sort","clip_compareIntersection","sink","segments","line","ringBuffer","lines","arguments","index","push","lineStart","lineEnd","rejoin","pop","concat","shift","result","buffer","ringSink","polygonStarted","clip","polygonStart","pointRing","ringStart","ringEnd","polygonEnd","Array","from","startInside","compareIntersection","stream","subject","forEach","segment","p0","p1","current","isSubject","sphere","pointLine","close","clean","ringSegments","filter","validSegment","intersectSegment","to","fromNormal","toNormal","intersect","lc","axb","a0","a1","b0","b1","intersectPointOnLine","intersectCoincident","src_intersect","ca","map","cb","clipNone","clip_polygon","geometry","clipGeometry","polygons","type","coordinates","clips","visible","ringRadians","c0","lambda00","phi00","v00","v0","_clean","apply","toConsumableArray","intersections","randsign","sph","distance","clipPolygonDistance","polygon_clipLine","direction","polygon_interpolate","clipPolygonSort","clipPolygon","clipstream","_","matrix","u","subtract","matrix_angle","matrix_length","multiply","polyhedral","tree","face","forward","node","project","transform","recurse","parent","edges","faceEdges","shared","found","sharedEdge","children","child","hasInverse","invert","faceInvert","inverse","faceDegrees","proj","src_projection","outline","edge","multiPoint","notPoles","bounds","inside","centroid","src_centroid","isArray","src_interpolate","preclip","some","octahedron_octahedron","polyhedral_octahedron","butterfly","faceProjection","gnomonic","scale","translate","rotate","faces","center","collignonRaw","alpha","kx","collignonK","collignon","waterman","w5","xyz","waterman_cartesian","hexagon","waterman_spherical","cornerNormals","parents","normals","cosphi","dot","voronoi","find","features","d0","Infinity","src_distance","site","build_tree","feature","slice","properties","sitecoordinates","id","faceFind","dodecahedral","A0","A1","A2","A3","ascending","NaN","leastIndex","values","minValue","compare","undefined","valueof","minIndex","err","_step2","_iterator2","_value","minIndex_minIndex","scan","lagrangeRaw","sinPhi","y0","x2","y2","complexMul","complexAdd","complexSub","complexNorm2","complexLogHypot","_a","_b","complexPow","arg","loh","cox_w","cox_w1","cox_m","lagrange1_2","coxRaw","rot","F0","F","H0","z3","h","sm_1","cox","stream_","rotateStream","sphereStream","src_stream","solve2d","MAX_ITERATIONS","eps","err2","da","db","tx","ty","ea","eb","pa","pb","dxa","dya","dxb","dyb","D","leeRaw","w","stereographic","sector","G0","G","leeSolver","q","asin1_3","centers","tetrahedron","tetrahedralLee","src_contains","GrayFullerRaw","SQRT_3","Z","el","dve","grayfuller","a1p","a2p","a3p","R","range","step","src_airocean","theta","vertices","polyhedron","tmp","mid","contains","airocean","airoceanRaw","icosahedral","hypot","ASIN_ONE_THD","centrums","configuration","sphereSym","planarSym","width","height","rotateOOB","xCen","yCen","inBounds","imagoRaw","faceInverse","r","th","f0","f1","steps","solve","obliquifySphc","latF","lonF","pole","lat1","lon1","lat0","lon0","tht0","isNaN","lon","lat","numSym","latR","lonR","centrum","testCentrum","relCoords","lonR0","rth","tht","faceProject","x0","output","rM","rR","th0","thBase","absCoords","coords","latf","innerFunc","obliquifyPlnr","imagoBlock","border","imagoWideRaw","imago","clipped","N","unshift","cube_phi1","cube","polyhedral_cube","cubic","cahillKeyes","cahillKeyesRaw","octahedron","ck","cosTheta","sinTheta","mg","CK","lengthMG","p2","deltaX","deltaY","totalLength","end","lineIntersection","slope1","point2","slope2","m1","m2","circleLineIntersection","cc","u1","u2","x1","y1","xc","yc","xy","xynew","cos60","sin60","equator","deltaMEq","lengthGF","pointG","lengthAB","pointF","pointE","jointE","jointT","pointM","jointF","pointA","lengthTorridSegment","lengthMiddleSegment","parallel73","p73","jF","lF","lengthAP73","pointT","lengthParallel73","parallel75","lengthAP75","ll2mp","mp2xy","lT","p15a","p15","flag15","l15","zoneA","zoneB","zoneC","zoneD","zoneE","pointD","zoneF","zoneG","p75","pointB","lF75","zoneH","p73a","lM","zoneI","zoneJ","pointC","radius","zoneK","zoneL","res","octant","mj2g","pointN","lengthMB","lengthMN","lengthNG","pointU","pointV","lengthMA","lengthParallel0to73At0","lengthParallel73to90At0","lengthAG","lengthBD","lengthBDE","lengthGFE","preliminaries","DEFAULT_PLANAR_PROJECTION_RAW","CARTESIAN_OFFSET","DEFAULT_PROJECTION_PARAMS","CLIP_POLY_SPHERICAL","N_SIDE","N_BOTTOM","complexLogRaw","planarProjectionRaw","aziComp","invLogComp","complexLog","cutoffLatitude","mutator","projection","topLeft","topRight","bottomRight","bottomLeft","__webpack_require__","__webpack_exports__","react__WEBPACK_IMPORTED_MODULE_0__","react__WEBPACK_IMPORTED_MODULE_0___default","memoize_one__WEBPACK_IMPORTED_MODULE_1__","_emotion_core__WEBPACK_IMPORTED_MODULE_2__","_Select_9fdb8cd0_browser_esm_js__WEBPACK_IMPORTED_MODULE_5__","_stateManager_04f734a2_browser_esm_js__WEBPACK_IMPORTED_MODULE_8__","_emotion_cache__WEBPACK_IMPORTED_MODULE_9__"],"mappings":"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","file":"static/js/85.9f0bcadb.chunk.js","sourcesContent":["export default function noop() {}","export default function pointEqual(a, b) {\n  return a && b && a[0] === b[0] && a[1] === b[1];\n}","import pointEqual from \"../pointEqual.js\";\n\nfunction Intersection(point, points, other, entry) {\n  this.x = point;\n  this.z = points;\n  this.o = other; // another intersection\n\n  this.e = entry; // is an entry?\n\n  this.v = false; // visited\n\n  this.n = this.p = null; // next & previous\n} // A generalized polygon clipping algorithm: given a polygon that has been cut\n// into its visible line segments, and rejoins the segments by interpolating\n// along the clip edge.\n\n\nexport default function (segments, compareIntersection, startInside, interpolate, stream) {\n  var subject = [],\n      clip = [],\n      i,\n      n;\n  segments.forEach(function (segment) {\n    if ((n = segment.length - 1) <= 0) return;\n    var n,\n        p0 = segment[0],\n        p1 = segment[n],\n        x; // If the first and last points of a segment are coincident, then treat as a\n    // closed ring. TODO if all rings are closed, then the winding order of the\n    // exterior ring should be checked.\n\n    if (pointEqual(p0, p1)) {\n      stream.lineStart();\n\n      for (i = 0; i < n; ++i) {\n        stream.point((p0 = segment[i])[0], p0[1]);\n      }\n\n      stream.lineEnd();\n      return;\n    }\n\n    subject.push(x = new Intersection(p0, segment, null, true));\n    clip.push(x.o = new Intersection(p0, null, x, false));\n    subject.push(x = new Intersection(p1, segment, null, false));\n    clip.push(x.o = new Intersection(p1, null, x, true));\n  });\n  if (!subject.length) return;\n  clip.sort(compareIntersection);\n  link(subject);\n  link(clip);\n\n  for (i = 0, n = clip.length; i < n; ++i) {\n    clip[i].e = startInside = !startInside;\n  }\n\n  var start = subject[0],\n      points,\n      point;\n\n  while (1) {\n    // Find first unvisited intersection.\n    var current = start,\n        isSubject = true;\n\n    while (current.v) {\n      if ((current = current.n) === start) return;\n    }\n\n    points = current.z;\n    stream.lineStart();\n\n    do {\n      current.v = current.o.v = true;\n\n      if (current.e) {\n        if (isSubject) {\n          for (i = 0, n = points.length; i < n; ++i) {\n            stream.point((point = points[i])[0], point[1]);\n          }\n        } else {\n          interpolate(current.x, current.n.x, 1, stream);\n        }\n\n        current = current.n;\n      } else {\n        if (isSubject) {\n          points = current.p.z;\n\n          for (i = points.length - 1; i >= 0; --i) {\n            stream.point((point = points[i])[0], point[1]);\n          }\n        } else {\n          interpolate(current.x, current.p.x, -1, stream);\n        }\n\n        current = current.p;\n      }\n\n      current = current.o;\n      points = current.z;\n      isSubject = !isSubject;\n    } while (!current.v);\n\n    stream.lineEnd();\n  }\n}\n\nfunction link(array) {\n  if (!(n = array.length)) return;\n  var n,\n      i = 0,\n      a = array[0],\n      b;\n\n  while (++i < n) {\n    a.n = b = array[i];\n    b.p = a;\n    a = b;\n  }\n\n  a.n = b = array[0];\n  b.p = a;\n}","export var abs = Math.abs;\nexport var atan = Math.atan;\nexport var atan2 = Math.atan2;\nexport var ceil = Math.ceil;\nexport var cos = Math.cos;\nexport var exp = Math.exp;\nexport var floor = Math.floor;\nexport var log = Math.log;\nexport var max = Math.max;\nexport var min = Math.min;\nexport var pow = Math.pow;\nexport var round = Math.round;\nexport var sign = Math.sign || function (x) {\n  return x > 0 ? 1 : x < 0 ? -1 : 0;\n};\nexport var sin = Math.sin;\nexport var tan = Math.tan;\nexport var epsilon = 1e-6;\nexport var epsilon2 = 1e-12;\nexport var pi = Math.PI;\nexport var halfPi = pi / 2;\nexport var quarterPi = pi / 4;\nexport var sqrt1_2 = Math.SQRT1_2;\nexport var sqrt2 = sqrt(2);\nexport var sqrtPi = sqrt(pi);\nexport var tau = pi * 2;\nexport var degrees = 180 / pi;\nexport var radians = pi / 180;\nexport function sinci(x) {\n  return x ? x / Math.sin(x) : 1;\n}\nexport function asin(x) {\n  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);\n}\nexport function acos(x) {\n  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);\n}\nexport function sqrt(x) {\n  return x > 0 ? Math.sqrt(x) : 0;\n}\nexport function tanh(x) {\n  x = exp(2 * x);\n  return (x - 1) / (x + 1);\n}\nexport function sinh(x) {\n  return (exp(x) - exp(-x)) / 2;\n}\nexport function cosh(x) {\n  return (exp(x) + exp(-x)) / 2;\n}\nexport function arsinh(x) {\n  return log(x + sqrt(x * x + 1));\n}\nexport function arcosh(x) {\n  return log(x + sqrt(x * x - 1));\n}","// Adds floating point numbers with twice the normal precision.\n// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and\n// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)\n// 305363 (1997).\n// Code adapted from GeographicLib by Charles F. F. Karney,\n// http://geographiclib.sourceforge.net/\nexport default function () {\n  return new Adder();\n}\n\nfunction Adder() {\n  this.reset();\n}\n\nAdder.prototype = {\n  constructor: Adder,\n  reset: function reset() {\n    this.s = // rounded value\n    this.t = 0; // exact error\n  },\n  add: function add(y) {\n    _add(temp, y, this.t);\n\n    _add(this, temp.s, this.s);\n\n    if (this.s) this.t += temp.t;else this.s = temp.t;\n  },\n  valueOf: function valueOf() {\n    return this.s;\n  }\n};\nvar temp = new Adder();\n\nfunction _add(adder, a, b) {\n  var x = adder.s = a + b,\n      bv = x - a,\n      av = x - bv;\n  adder.t = a - av + (b - bv);\n}","import { asin, atan2, cos, degrees, epsilon2, radians, sin, sqrt } from \"./math.js\";\nexport function spherical(cartesian) {\n  return [atan2(cartesian[1], cartesian[0]), asin(cartesian[2])];\n}\nexport function sphericalDegrees(cartesian) {\n  var c = spherical(cartesian);\n  return [c[0] * degrees, c[1] * degrees];\n}\nexport function cartesian(spherical) {\n  var lambda = spherical[0],\n      phi = spherical[1],\n      cosPhi = cos(phi);\n  return [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];\n}\nexport function cartesianDegrees(spherical) {\n  return cartesian([spherical[0] * radians, spherical[1] * radians]);\n}\nexport function cartesianDot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\nexport function cartesianCross(a, b) {\n  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];\n} // TODO return a\n\nexport function cartesianAddInPlace(a, b) {\n  a[0] += b[0], a[1] += b[1], a[2] += b[2];\n}\nexport function cartesianScale(vector, k) {\n  return [vector[0] * k, vector[1] * k, vector[2] * k];\n} // TODO return d\n\nexport function cartesianNormalizeInPlace(d) {\n  var l = sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\n  d[0] /= l, d[1] /= l, d[2] /= l;\n}\nexport function cartesianEqual(a, b) {\n  var dx = b[0] - a[0],\n      dy = b[1] - a[1],\n      dz = b[2] - a[2];\n  return dx * dx + dy * dy + dz * dz < epsilon2 * epsilon2;\n}","import adder from \"./adder.js\";\nimport { cartesian, cartesianCross, cartesianNormalizeInPlace } from \"./cartesian.js\";\nimport { asin, atan2, cos, epsilon, pi, quarterPi, sin, tau } from \"./math.js\";\nvar sum = adder();\nexport default function (polygon, point) {\n  var lambda = point[0],\n      phi = point[1],\n      normal = [sin(lambda), -cos(lambda), 0],\n      angle = 0,\n      winding = 0;\n  sum.reset();\n\n  for (var i = 0, n = polygon.length; i < n; ++i) {\n    if (!(m = (ring = polygon[i]).length)) continue;\n    var ring,\n        m,\n        point0 = ring[m - 1],\n        lambda0 = point0[0],\n        phi0 = point0[1] / 2 + quarterPi,\n        sinPhi0 = sin(phi0),\n        cosPhi0 = cos(phi0);\n\n    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {\n      var point1 = ring[j],\n          lambda1 = point1[0],\n          phi1 = point1[1] / 2 + quarterPi,\n          sinPhi1 = sin(phi1),\n          cosPhi1 = cos(phi1),\n          delta = lambda1 - lambda0,\n          sign = delta >= 0 ? 1 : -1,\n          absDelta = sign * delta,\n          antimeridian = absDelta > pi,\n          k = sinPhi0 * sinPhi1;\n      sum.add(atan2(k * sign * sin(absDelta), cosPhi0 * cosPhi1 + k * cos(absDelta)));\n      angle += antimeridian ? delta + sign * tau : delta; // Are the longitudes either side of the points meridian (lambda),\n      // and are the latitudes smaller than the parallel (phi)?\n\n      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {\n        var arc = cartesianCross(cartesian(point0), cartesian(point1));\n        cartesianNormalizeInPlace(arc);\n        var intersection = cartesianCross(normal, arc);\n        cartesianNormalizeInPlace(intersection);\n        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin(intersection[2]);\n\n        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {\n          winding += antimeridian ^ delta >= 0 ? 1 : -1;\n        }\n      }\n    }\n  } // First, determine whether the South pole is inside or outside:\n  //\n  // It is inside if:\n  // * the polygon winds around it in a clockwise direction.\n  // * the polygon does not (cumulatively) wind around it, but has a negative\n  //   (counter-clockwise) area.\n  //\n  // Second, count the (signed) number of times a segment crosses a lambda\n  // from the point to the South pole.  If it is zero, then the point is the\n  // same side as the South pole.\n\n\n  return (angle < -epsilon || angle < epsilon && sum < -epsilon) ^ winding & 1;\n}","import _regeneratorRuntime from \"/Users/linying/codespace/Lyzzz-s-Blog/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _createForOfIteratorHelper from \"/Users/linying/codespace/Lyzzz-s-Blog/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(flatten);\n\nfunction flatten(arrays) {\n  var _iterator, _step, array;\n\n  return _regeneratorRuntime.wrap(function flatten$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          _iterator = _createForOfIteratorHelper(arrays);\n          _context.prev = 1;\n\n          _iterator.s();\n\n        case 3:\n          if ((_step = _iterator.n()).done) {\n            _context.next = 8;\n            break;\n          }\n\n          array = _step.value;\n          return _context.delegateYield(array, \"t0\", 6);\n\n        case 6:\n          _context.next = 3;\n          break;\n\n        case 8:\n          _context.next = 13;\n          break;\n\n        case 10:\n          _context.prev = 10;\n          _context.t1 = _context[\"catch\"](1);\n\n          _iterator.e(_context.t1);\n\n        case 13:\n          _context.prev = 13;\n\n          _iterator.f();\n\n          return _context.finish(13);\n\n        case 16:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked, null, [[1, 10, 13, 16]]);\n}\n\nexport default function merge(arrays) {\n  return Array.from(flatten(arrays));\n}","import clipBuffer from \"./buffer.js\";\nimport clipRejoin from \"./rejoin.js\";\nimport { epsilon, halfPi } from \"../math.js\";\nimport polygonContains from \"../polygonContains.js\";\nimport { merge } from \"d3-array\";\nexport default function (pointVisible, clipLine, interpolate, start, sort) {\n  if (typeof sort === \"undefined\") sort = compareIntersection;\n  return function (sink) {\n    var line = clipLine(sink),\n        ringBuffer = clipBuffer(),\n        ringSink = clipLine(ringBuffer),\n        polygonStarted = false,\n        polygon,\n        segments,\n        ring;\n    var clip = {\n      point: point,\n      lineStart: lineStart,\n      lineEnd: lineEnd,\n      polygonStart: function polygonStart() {\n        clip.point = pointRing;\n        clip.lineStart = ringStart;\n        clip.lineEnd = ringEnd;\n        segments = [];\n        polygon = [];\n      },\n      polygonEnd: function polygonEnd() {\n        clip.point = point;\n        clip.lineStart = lineStart;\n        clip.lineEnd = lineEnd;\n        segments = merge(segments);\n        var startInside = polygonContains(polygon, start);\n\n        if (segments.length) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          clipRejoin(segments, sort, startInside, interpolate, sink);\n        } else if (startInside) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          interpolate(null, null, 1, sink);\n        }\n\n        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;\n        segments = polygon = null;\n      },\n      sphere: function sphere() {\n        interpolate(null, null, 1, sink);\n      }\n    };\n\n    function point(lambda, phi) {\n      if (pointVisible(lambda, phi)) sink.point(lambda, phi);\n    }\n\n    function pointLine(lambda, phi) {\n      line.point(lambda, phi);\n    }\n\n    function lineStart() {\n      clip.point = pointLine;\n      line.lineStart();\n    }\n\n    function lineEnd() {\n      clip.point = point;\n      line.lineEnd();\n    }\n\n    function pointRing(lambda, phi, close) {\n      ring.push([lambda, phi]);\n      ringSink.point(lambda, phi, close);\n    }\n\n    function ringStart() {\n      ringSink.lineStart();\n      ring = [];\n    }\n\n    function ringEnd() {\n      pointRing(ring[0][0], ring[0][1], true);\n      ringSink.lineEnd();\n      var clean = ringSink.clean(),\n          ringSegments = ringBuffer.result(),\n          i,\n          n = ringSegments.length,\n          m,\n          segment,\n          point;\n      ring.pop();\n      polygon.push(ring);\n      ring = null;\n      if (!n) return; // No intersections.\n\n      if (clean & 1) {\n        segment = ringSegments[0];\n\n        if ((m = segment.length - 1) > 0) {\n          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;\n          sink.lineStart();\n\n          for (i = 0; i < m; ++i) {\n            sink.point((point = segment[i])[0], point[1]);\n          }\n\n          sink.lineEnd();\n        }\n\n        return;\n      } // Rejoin connected segments.\n      // TODO reuse ringBuffer.rejoin()?\n\n\n      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\n      segments.push(ringSegments.filter(validSegment));\n    }\n\n    return clip;\n  };\n}\n\nfunction validSegment(segment) {\n  return segment.length > 1;\n} // Intersections are sorted along the clip edge. For both antimeridian cutting\n// and circle clipping, the same comparison is used.\n\n\nfunction compareIntersection(a, b) {\n  return ((a = a.x)[0] < 0 ? a[1] - halfPi - epsilon : halfPi - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi - epsilon : halfPi - b[1]);\n}","import noop from \"../noop.js\";\nexport default function () {\n  var lines = [],\n      line;\n  return {\n    point: function point(x, y, i, t) {\n      var point = [x, y]; // when called by clipPolygon, store index and t\n\n      if (arguments.length > 2) {\n        point.index = i;\n        point.t = t;\n      }\n\n      line.push(point);\n    },\n    lineStart: function lineStart() {\n      lines.push(line = []);\n    },\n    lineEnd: noop,\n    rejoin: function rejoin() {\n      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));\n    },\n    result: function result() {\n      var result = lines;\n      lines = [];\n      line = null;\n      return result;\n    }\n  };\n}","import { abs, acos, cos, degrees, epsilon, epsilon2, pi, radians } from \"./math.js\";\nimport { cartesian, cartesianCross, cartesianDot, cartesianEqual, cartesianNormalizeInPlace, spherical } from \"./cartesian.js\";\nexport function intersectSegment(from, to) {\n  this.from = from, this.to = to;\n  this.normal = cartesianCross(from, to);\n  this.fromNormal = cartesianCross(this.normal, from);\n  this.toNormal = cartesianCross(this.normal, to);\n  this.l = acos(cartesianDot(from, to));\n} // >> here a and b are segments processed by intersectSegment\n\nexport function intersect(a, b) {\n  if (cartesianEqual(a.from, b.from) || cartesianEqual(a.from, b.to)) return a.from;\n  if (cartesianEqual(a.to, b.from) || cartesianEqual(a.to, b.to)) return a.to;\n  var lc = a.l + b.l < pi ? cos(a.l + b.l) - epsilon : -1;\n  if (cartesianDot(a.from, b.from) < lc || cartesianDot(a.from, b.to) < lc || cartesianDot(a.to, b.from) < lc || cartesianDot(a.to, b.to) < lc) return;\n  var axb = cartesianCross(a.normal, b.normal);\n  cartesianNormalizeInPlace(axb);\n  var a0 = cartesianDot(axb, a.fromNormal),\n      a1 = cartesianDot(axb, a.toNormal),\n      b0 = cartesianDot(axb, b.fromNormal),\n      b1 = cartesianDot(axb, b.toNormal); // check if the candidate lies on both segments\n  // or is almost equal to one of the four points\n\n  if (a0 > 0 && a1 < 0 && b0 > 0 && b1 < 0 || a0 >= 0 && a1 <= 0 && b0 >= 0 && b1 <= 0 && (cartesianEqual(axb, a.from) || cartesianEqual(axb, a.to) || cartesianEqual(axb, b.from) || cartesianEqual(axb, b.to))) return axb; // same test for the antipode\n\n  axb[0] = -axb[0];\n  axb[1] = -axb[1];\n  axb[2] = -axb[2];\n  a0 = -a0;\n  a1 = -a1;\n  b0 = -b0;\n  b1 = -b1;\n  if (a0 > 0 && a1 < 0 && b0 > 0 && b1 < 0 || a0 >= 0 && a1 <= 0 && b0 >= 0 && b1 <= 0 && (cartesianEqual(axb, a.from) || cartesianEqual(axb, a.to) || cartesianEqual(axb, b.from) || cartesianEqual(axb, b.to))) return axb;\n}\nexport function intersectPointOnLine(p, a) {\n  var a0 = cartesianDot(p, a.fromNormal),\n      a1 = cartesianDot(p, a.toNormal);\n  p = cartesianDot(p, a.normal);\n  return abs(p) < epsilon2 && (a0 > -epsilon2 && a1 < epsilon2 || a0 < epsilon2 && a1 > -epsilon2);\n}\nexport var intersectCoincident = {};\nexport default function (a, b) {\n  var ca = a.map(function (p) {\n    return cartesian(p.map(function (d) {\n      return d * radians;\n    }));\n  }),\n      cb = b.map(function (p) {\n    return cartesian(p.map(function (d) {\n      return d * radians;\n    }));\n  });\n  var i = intersect(new intersectSegment(ca[0], ca[1]), new intersectSegment(cb[0], cb[1]));\n  return !i ? i : spherical(i).map(function (d) {\n    return d * degrees;\n  });\n}","import _toConsumableArray from \"/Users/linying/codespace/Lyzzz-s-Blog/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport clip from \"./index.js\";\nimport { atan2, cos, max, min, pi, radians, sign, sin, sqrt } from \"../math.js\";\nimport { cartesian, cartesianCross, cartesianDot, cartesianEqual, spherical } from \"../cartesian.js\";\nimport { intersectCoincident, intersectPointOnLine, intersectSegment, intersect } from \"../intersect.js\";\nimport { default as polygonContains } from \"../polygonContains.js\";\n\nvar clipNone = function clipNone(stream) {\n  return stream;\n}; // clipPolygon\n\n\nexport default function (geometry) {\n  function clipGeometry(geometry) {\n    var polygons;\n\n    if (geometry.type === \"MultiPolygon\") {\n      polygons = geometry.coordinates;\n    } else if (geometry.type === \"Polygon\") {\n      polygons = [geometry.coordinates];\n    } else {\n      return clipNone;\n    }\n\n    var clips = polygons.map(function (polygon) {\n      polygon = polygon.map(ringRadians);\n      var pointVisible = visible(polygon),\n          segments = ringSegments(polygon[0]); // todo holes?\n\n      return clip(pointVisible, clipLine(segments, pointVisible), interpolate(segments, polygon), polygon[0][0], clipPolygonSort);\n    });\n\n    var clipPolygon = function clipPolygon(stream) {\n      var clipstream = clips.map(function (clip) {\n        return clip(stream);\n      });\n      return {\n        point: function point(lambda, phi) {\n          clipstream.forEach(function (clip) {\n            return clip.point(lambda, phi);\n          });\n        },\n        lineStart: function lineStart() {\n          clipstream.forEach(function (clip) {\n            return clip.lineStart();\n          });\n        },\n        lineEnd: function lineEnd() {\n          clipstream.forEach(function (clip) {\n            return clip.lineEnd();\n          });\n        },\n        polygonStart: function polygonStart() {\n          clipstream.forEach(function (clip) {\n            return clip.polygonStart();\n          });\n        },\n        polygonEnd: function polygonEnd() {\n          clipstream.forEach(function (clip) {\n            return clip.polygonEnd();\n          });\n        },\n        sphere: function sphere() {\n          clipstream.forEach(function (clip) {\n            return clip.sphere();\n          });\n        }\n      };\n    };\n\n    clipPolygon.polygon = function (_) {\n      return _ ? (geometry = _, clipGeometry(geometry)) : geometry;\n    };\n\n    return clipPolygon;\n  }\n\n  return clipGeometry(geometry);\n}\n\nfunction ringRadians(ring) {\n  return ring.map(function (point) {\n    return [point[0] * radians, point[1] * radians];\n  });\n}\n\nfunction ringSegments(ring) {\n  var c,\n      c0,\n      segments = [];\n  ring.forEach(function (point, i) {\n    c = cartesian(point);\n    if (i) segments.push(new intersectSegment(c0, c));\n    c0 = c;\n    return point;\n  });\n  return segments;\n}\n\nfunction clipPolygonSort(a, b) {\n  a = a.x, b = b.x;\n  return a.index - b.index || a.t - b.t;\n}\n\nfunction interpolate(segments, polygon) {\n  return function (from, to, direction, stream) {\n    if (from == null) {\n      stream.polygonStart();\n      polygon.forEach(function (ring) {\n        stream.lineStart();\n        ring.forEach(function (point) {\n          stream.point(point[0], point[1]);\n        });\n        stream.lineEnd();\n      });\n      stream.polygonEnd();\n    } else if (from.index !== to.index && from.index != null && to.index != null) {\n      for (var i = from.index; i !== to.index; i = (i + direction + segments.length) % segments.length) {\n        var segment = segments[i],\n            point = spherical(direction > 0 ? segment.to : segment.from);\n        stream.point(point[0], point[1]);\n      }\n    } else if (from.index === to.index && from.t > to.t && from.index != null && to.index != null) {\n      for (i = 0; i < segments.length; i++) {\n        segment = segments[(from.index + i * direction + segments.length) % segments.length], point = spherical(direction > 0 ? segment.to : segment.from);\n        stream.point(point[0], point[1]);\n      }\n    }\n  };\n} // Geodesic coordinates for two 3D points.\n\n\nfunction clipPolygonDistance(a, b) {\n  var axb = cartesianCross(a, b);\n  return atan2(sqrt(cartesianDot(axb, axb)), cartesianDot(a, b));\n}\n\nfunction visible(polygon) {\n  return function (lambda, phi) {\n    return polygonContains(polygon, [lambda, phi]);\n  };\n}\n\nfunction randsign(i, j) {\n  return sign(sin(100 * i + j));\n}\n\nfunction clipLine(segments, pointVisible) {\n  return function (stream) {\n    var point0,\n        lambda00,\n        phi00,\n        v00,\n        v0,\n        _clean,\n        line,\n        lines = [];\n\n    return {\n      lineStart: function lineStart() {\n        point0 = null;\n        _clean = 1;\n        line = [];\n      },\n      lineEnd: function lineEnd() {\n        if (v0) lines.push(line);\n        lines.forEach(function (line) {\n          stream.lineStart();\n          line.forEach(function (point) {\n            stream.point.apply(stream, _toConsumableArray(point)); // can have 4 dimensions\n          });\n          stream.lineEnd();\n        });\n        lines = [];\n      },\n      point: function point(lambda, phi, close) {\n        if (cos(lambda) == -1) lambda -= sign(sin(lambda)) * 1e-5; // move away from -180/180 https://github.com/d3/d3-geo/pull/108#issuecomment-323798937\n\n        if (close) lambda = lambda00, phi = phi00;\n        var point = cartesian([lambda, phi]),\n            v = v0,\n            intersection,\n            i,\n            j,\n            s,\n            t;\n\n        if (point0) {\n          var segment = new intersectSegment(point0, point),\n              intersections = [];\n\n          for (i = 0, j = 100; i < segments.length && j > 0; ++i) {\n            s = segments[i];\n            intersection = intersect(segment, s);\n\n            if (intersection) {\n              if (intersection === intersectCoincident || cartesianEqual(intersection, point0) || cartesianEqual(intersection, point) || cartesianEqual(intersection, s.from) || cartesianEqual(intersection, s.to)) {\n                t = 1e-4;\n                lambda = (lambda + 3 * pi + randsign(i, j) * t) % (2 * pi) - pi;\n                phi = min(pi / 2 - 1e-4, max(1e-4 - pi / 2, phi + randsign(i, j) * t));\n                segment = new intersectSegment(point0, point = cartesian([lambda, phi]));\n                i = -1, --j;\n                intersections.length = 0;\n                continue;\n              }\n\n              var sph = spherical(intersection);\n              intersection.distance = clipPolygonDistance(point0, intersection);\n              intersection.index = i;\n              intersection.t = clipPolygonDistance(s.from, intersection);\n              intersection[0] = sph[0], intersection[1] = sph[1], intersection.pop();\n              intersections.push(intersection);\n            }\n          }\n\n          if (intersections.length) {\n            _clean = 0;\n            intersections.sort(function (a, b) {\n              return a.distance - b.distance;\n            });\n\n            for (i = 0; i < intersections.length; ++i) {\n              intersection = intersections[i];\n              v = !v;\n\n              if (v) {\n                line = [];\n                line.push([intersection[0], intersection[1], intersection.index, intersection.t]);\n              } else {\n                line.push([intersection[0], intersection[1], intersection.index, intersection.t]);\n                lines.push(line);\n              }\n            }\n          }\n\n          if (v) line.push([lambda, phi]);\n        } else {\n          for (i = 0, j = 100; i < segments.length && j > 0; ++i) {\n            s = segments[i];\n\n            if (intersectPointOnLine(point, s)) {\n              t = 1e-4;\n              lambda = (lambda + 3 * pi + randsign(i, j) * t) % (2 * pi) - pi;\n              phi = min(pi / 2 - 1e-4, max(1e-4 - pi / 2, phi + randsign(i, j) * t));\n              point = cartesian([lambda, phi]);\n              i = -1, --j;\n            }\n          }\n\n          v00 = v = pointVisible(lambda00 = lambda, phi00 = phi);\n          if (v) line = [], line.push([lambda, phi]);\n        }\n\n        point0 = point, v0 = v;\n      },\n      // Rejoin first and last segments if there were intersections and the first\n      // and last points were visible.\n      clean: function clean() {\n        return _clean | (v00 && v0) << 1;\n      }\n    };\n  };\n}","import { atan2, cos, sin, sqrt } from \"../math.js\"; // Note: 6-element arrays are used to denote the 3x3 affine transform matrix:\n// [a, b, c,\n//  d, e, f,\n//  0, 0, 1] - this redundant row is left out.\n// Transform matrix for [a0, a1] -> [b0, b1].\n\nexport default function (a, b) {\n  var u = subtract(a[1], a[0]),\n      v = subtract(b[1], b[0]),\n      phi = angle(u, v),\n      s = length(u) / length(v);\n  return multiply([1, 0, a[0][0], 0, 1, a[0][1]], multiply([s, 0, 0, 0, s, 0], multiply([cos(phi), sin(phi), 0, -sin(phi), cos(phi), 0], [1, 0, -b[0][0], 0, 1, -b[0][1]])));\n} // Inverts a transform matrix.\n\nexport function inverse(m) {\n  var k = 1 / (m[0] * m[4] - m[1] * m[3]);\n  return [k * m[4], -k * m[1], k * (m[1] * m[5] - m[2] * m[4]), -k * m[3], k * m[0], k * (m[2] * m[3] - m[0] * m[5])];\n} // Multiplies two 3x2 matrices.\n\nexport function multiply(a, b) {\n  return [a[0] * b[0] + a[1] * b[3], a[0] * b[1] + a[1] * b[4], a[0] * b[2] + a[1] * b[5] + a[2], a[3] * b[0] + a[4] * b[3], a[3] * b[1] + a[4] * b[4], a[3] * b[2] + a[4] * b[5] + a[5]];\n} // Subtracts 2D vectors.\n\nfunction subtract(a, b) {\n  return [a[0] - b[0], a[1] - b[1]];\n} // Magnitude of a 2D vector.\n\n\nfunction length(v) {\n  return sqrt(v[0] * v[0] + v[1] * v[1]);\n} // Angle between two 2D vectors.\n\n\nfunction angle(a, b) {\n  return atan2(a[0] * b[1] - a[1] * b[0], a[0] * b[0] + a[1] * b[1]);\n}","import { geoBounds as bounds, geoCentroid as centroid, geoInterpolate as interpolate, geoProjection as projection } from \"d3-geo\";\nimport { default as clipPolygon } from \"../clip/polygon.js\";\nimport { abs, degrees, epsilon, radians } from \"../math.js\";\nimport { default as matrix, multiply, inverse } from \"./matrix.js\";\nimport pointEqual from \"../pointEqual.js\"; // Creates a polyhedral projection.\n//  * tree: a spanning tree of polygon faces.  Nodes are automatically\n//    augmented with a transform matrix.\n//  * face: a function that returns the appropriate node for a given {lambda, phi}\n//    point (radians).\n\nexport default function (tree, face) {\n  recurse(tree, {\n    transform: null\n  });\n\n  function recurse(node, parent) {\n    node.edges = faceEdges(node.face); // Find shared edge.\n\n    if (parent.face) {\n      var shared = node.shared = sharedEdge(node.face, parent.face),\n          m = matrix(shared.map(parent.project), shared.map(node.project));\n      node.transform = parent.transform ? multiply(parent.transform, m) : m; // Replace shared edge in parent edges array.\n\n      var edges = parent.edges;\n\n      for (var i = 0, n = edges.length; i < n; ++i) {\n        if (pointEqual(shared[0], edges[i][1]) && pointEqual(shared[1], edges[i][0])) edges[i] = node;\n        if (pointEqual(shared[0], edges[i][0]) && pointEqual(shared[1], edges[i][1])) edges[i] = node;\n      }\n\n      edges = node.edges;\n\n      for (i = 0, n = edges.length; i < n; ++i) {\n        if (pointEqual(shared[0], edges[i][0]) && pointEqual(shared[1], edges[i][1])) edges[i] = parent;\n        if (pointEqual(shared[0], edges[i][1]) && pointEqual(shared[1], edges[i][0])) edges[i] = parent;\n      }\n    } else {\n      node.transform = parent.transform;\n    }\n\n    if (node.children) {\n      node.children.forEach(function (child) {\n        recurse(child, node);\n      });\n    }\n\n    return node;\n  }\n\n  function forward(lambda, phi) {\n    var node = face(lambda, phi),\n        point = node.project([lambda * degrees, phi * degrees]),\n        t;\n\n    if (t = node.transform) {\n      return [t[0] * point[0] + t[1] * point[1] + t[2], -(t[3] * point[0] + t[4] * point[1] + t[5])];\n    }\n\n    point[1] = -point[1];\n    return point;\n  } // Naive inverse!  A faster solution would use bounding boxes, or even a\n  // polygonal quadtree.\n\n\n  if (hasInverse(tree)) forward.invert = function (x, y) {\n    var coordinates = faceInvert(tree, [x, -y]);\n    return coordinates && (coordinates[0] *= radians, coordinates[1] *= radians, coordinates);\n  };\n\n  function faceInvert(node, coordinates) {\n    var invert = node.project.invert,\n        t = node.transform,\n        point = coordinates;\n\n    if (t) {\n      t = inverse(t);\n      point = [t[0] * point[0] + t[1] * point[1] + t[2], t[3] * point[0] + t[4] * point[1] + t[5]];\n    }\n\n    if (invert && node === faceDegrees(p = invert(point))) return p;\n    var p,\n        children = node.children;\n\n    for (var i = 0, n = children && children.length; i < n; ++i) {\n      if (p = faceInvert(children[i], coordinates)) return p;\n    }\n  }\n\n  function faceDegrees(coordinates) {\n    return face(coordinates[0] * radians, coordinates[1] * radians);\n  }\n\n  var proj = projection(forward); // run around the mesh of faces and stream all vertices to create the clipping polygon\n\n  var polygon = [];\n  outline({\n    point: function point(lambda, phi) {\n      polygon.push([lambda, phi]);\n    }\n  }, tree);\n  polygon.push(polygon[0]);\n  proj.preclip(clipPolygon({\n    type: \"Polygon\",\n    coordinates: [polygon]\n  }));\n\n  proj.tree = function () {\n    return tree;\n  };\n\n  return proj;\n}\n\nfunction outline(stream, node, parent) {\n  var point,\n      edges = node.edges,\n      n = edges.length,\n      edge,\n      multiPoint = {\n    type: \"MultiPoint\",\n    coordinates: node.face\n  },\n      notPoles = node.face.filter(function (d) {\n    return abs(d[1]) !== 90;\n  }),\n      b = bounds({\n    type: \"MultiPoint\",\n    coordinates: notPoles\n  }),\n      inside = false,\n      j = -1,\n      dx = b[1][0] - b[0][0]; // TODO\n\n  node.centroid = dx === 180 || dx === 360 ? [(b[0][0] + b[1][0]) / 2, (b[0][1] + b[1][1]) / 2] : centroid(multiPoint); // First find the shared edge\n\n  if (parent) while (++j < n) {\n    if (edges[j] === parent) break;\n  }\n  ++j;\n\n  for (var i = 0; i < n; ++i) {\n    edge = edges[(i + j) % n];\n\n    if (Array.isArray(edge)) {\n      if (!inside) {\n        stream.point((point = interpolate(edge[0], node.centroid)(epsilon))[0], point[1]);\n        inside = true;\n      }\n\n      stream.point((point = interpolate(edge[1], node.centroid)(epsilon))[0], point[1]);\n    } else {\n      inside = false;\n      if (edge !== parent) outline(stream, edge, node);\n    }\n  }\n} // Finds a shared edge given two clockwise polygons.\n\n\nfunction sharedEdge(a, b) {\n  var x,\n      y,\n      n = a.length,\n      found = null;\n\n  for (var i = 0; i < n; ++i) {\n    x = a[i];\n\n    for (var j = b.length; --j >= 0;) {\n      y = b[j];\n\n      if (x[0] === y[0] && x[1] === y[1]) {\n        if (found) return [found, x];\n        found = x;\n      }\n    }\n  }\n} // Converts an array of n face vertices to an array of n + 1 edges.\n\n\nfunction faceEdges(face) {\n  var n = face.length,\n      edges = [];\n\n  for (var a = face[n - 1], i = 0; i < n; ++i) {\n    edges.push([a, a = face[i]]);\n  }\n\n  return edges;\n}\n\nfunction hasInverse(node) {\n  return node.project.invert || node.children && node.children.some(hasInverse);\n}","// TODO generate on-the-fly to avoid external modification.\nvar octahedron = [[0, 90], [-90, 0], [0, 0], [90, 0], [180, 0], [0, -90]];\nexport default [[0, 2, 1], [0, 3, 2], [5, 1, 2], [5, 2, 3], [0, 1, 4], [0, 4, 3], [5, 4, 1], [5, 3, 4]].map(function (face) {\n  return face.map(function (i) {\n    return octahedron[i];\n  });\n});","import { geoCentroid as centroid, geoGnomonic as gnomonic } from \"d3-geo\";\nimport { pi } from \"../math.js\";\nimport polyhedral from \"./index.js\";\nimport octahedron from \"./octahedron.js\";\nexport default function (faceProjection) {\n  faceProjection = faceProjection || function (face) {\n    var c = centroid({\n      type: \"MultiPoint\",\n      coordinates: face\n    });\n    return gnomonic().scale(1).translate([0, 0]).rotate([-c[0], -c[1]]);\n  };\n\n  var faces = octahedron.map(function (face) {\n    return {\n      face: face,\n      project: faceProjection(face)\n    };\n  });\n  [-1, 0, 0, 1, 0, 1, 4, 5].forEach(function (d, i) {\n    var node = faces[d];\n    node && (node.children || (node.children = [])).push(faces[i]);\n  });\n  return polyhedral(faces[0], function (lambda, phi) {\n    return faces[lambda < -pi / 2 ? phi < 0 ? 6 : 4 : lambda < 0 ? phi < 0 ? 2 : 0 : lambda < pi / 2 ? phi < 0 ? 3 : 1 : phi < 0 ? 7 : 5];\n  }).angle(-30).scale(101.858).center([0, 45]);\n}","// code duplicated from d3-geo-projection\nimport { asin, pi, sin, sqrt, sqrtPi } from \"./math.js\";\nexport function collignonRaw(lambda, phi) {\n  var alpha = sqrt(1 - sin(phi));\n  return [2 / sqrtPi * lambda * alpha, sqrtPi * (1 - alpha)];\n}\n\ncollignonRaw.invert = function (x, y) {\n  var lambda = (lambda = y / sqrtPi - 1) * lambda;\n  return [lambda > 0 ? x * sqrt(pi / lambda) / 2 : 0, asin(1 - lambda)];\n};","import { geoCentroid as centroid, geoProjection as projection } from \"d3-geo\";\nimport { collignonRaw } from \"../collignon.js\";\nimport { pi, sqrt } from \"../math.js\";\nimport polyhedral from \"./index.js\";\nimport octahedron from \"./octahedron.js\";\nvar kx = 2 / sqrt(3);\n\nfunction collignonK(a, b) {\n  var p = collignonRaw(a, b);\n  return [p[0] * kx, p[1]];\n}\n\ncollignonK.invert = function (x, y) {\n  return collignonRaw.invert(x / kx, y);\n};\n\nexport default function (faceProjection) {\n  faceProjection = faceProjection || function (face) {\n    var c = centroid({\n      type: \"MultiPoint\",\n      coordinates: face\n    });\n    return projection(collignonK).translate([0, 0]).scale(1).rotate(c[1] > 0 ? [-c[0], 0] : [180 - c[0], 180]);\n  };\n\n  var faces = octahedron.map(function (face) {\n    return {\n      face: face,\n      project: faceProjection(face)\n    };\n  });\n  [-1, 0, 0, 1, 0, 1, 4, 5].forEach(function (d, i) {\n    var node = faces[d];\n    node && (node.children || (node.children = [])).push(faces[i]);\n  });\n  return polyhedral(faces[0], function (lambda, phi) {\n    return faces[lambda < -pi / 2 ? phi < 0 ? 6 : 4 : lambda < 0 ? phi < 0 ? 2 : 0 : lambda < pi / 2 ? phi < 0 ? 3 : 1 : phi < 0 ? 7 : 5];\n  }).angle(-30).scale(121.906).center([0, 48.5904]);\n}","import { geoCentroid as centroid, geoGnomonic as gnomonic } from \"d3-geo\";\nimport { asin, atan2, cos, degrees, max, min, pi, radians, sin } from \"../math.js\";\nimport polyhedral from \"./index.js\";\nimport octahedron from \"./octahedron.js\";\nexport default function (faceProjection) {\n  faceProjection = faceProjection || function (face) {\n    var c = face.length === 6 ? centroid({\n      type: \"MultiPoint\",\n      coordinates: face\n    }) : face[0];\n    return gnomonic().scale(1).translate([0, 0]).rotate([-c[0], -c[1]]);\n  };\n\n  var w5 = octahedron.map(function (face) {\n    var xyz = face.map(cartesian),\n        n = xyz.length,\n        a = xyz[n - 1],\n        b,\n        hexagon = [];\n\n    for (var i = 0; i < n; ++i) {\n      b = xyz[i];\n      hexagon.push(spherical([a[0] * 0.9486832980505138 + b[0] * 0.31622776601683794, a[1] * 0.9486832980505138 + b[1] * 0.31622776601683794, a[2] * 0.9486832980505138 + b[2] * 0.31622776601683794]), spherical([b[0] * 0.9486832980505138 + a[0] * 0.31622776601683794, b[1] * 0.9486832980505138 + a[1] * 0.31622776601683794, b[2] * 0.9486832980505138 + a[2] * 0.31622776601683794]));\n      a = b;\n    }\n\n    return hexagon;\n  });\n  var cornerNormals = [];\n  var parents = [-1, 0, 0, 1, 0, 1, 4, 5];\n  w5.forEach(function (hexagon, j) {\n    var face = octahedron[j],\n        n = face.length,\n        normals = cornerNormals[j] = [];\n\n    for (var i = 0; i < n; ++i) {\n      w5.push([face[i], hexagon[(i * 2 + 2) % (2 * n)], hexagon[(i * 2 + 1) % (2 * n)]]);\n      parents.push(j);\n      normals.push(cross(cartesian(hexagon[(i * 2 + 2) % (2 * n)]), cartesian(hexagon[(i * 2 + 1) % (2 * n)])));\n    }\n  });\n  var faces = w5.map(function (face) {\n    return {\n      project: faceProjection(face),\n      face: face\n    };\n  });\n  parents.forEach(function (d, i) {\n    var parent = faces[d];\n    parent && (parent.children || (parent.children = [])).push(faces[i]);\n  });\n\n  function face(lambda, phi) {\n    var cosphi = cos(phi),\n        p = [cosphi * cos(lambda), cosphi * sin(lambda), sin(phi)];\n    var hexagon = lambda < -pi / 2 ? phi < 0 ? 6 : 4 : lambda < 0 ? phi < 0 ? 2 : 0 : lambda < pi / 2 ? phi < 0 ? 3 : 1 : phi < 0 ? 7 : 5;\n    var n = cornerNormals[hexagon];\n    return faces[dot(n[0], p) < 0 ? 8 + 3 * hexagon : dot(n[1], p) < 0 ? 8 + 3 * hexagon + 1 : dot(n[2], p) < 0 ? 8 + 3 * hexagon + 2 : hexagon];\n  }\n\n  return polyhedral(faces[0], face).angle(-30).scale(110.625).center([0, 45]);\n}\n\nfunction dot(a, b) {\n  for (var i = 0, n = a.length, s = 0; i < n; ++i) {\n    s += a[i] * b[i];\n  }\n\n  return s;\n}\n\nfunction cross(a, b) {\n  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];\n} // Converts 3D Cartesian to spherical coordinates (degrees).\n\n\nfunction spherical(cartesian) {\n  return [atan2(cartesian[1], cartesian[0]) * degrees, asin(max(-1, min(1, cartesian[2]))) * degrees];\n} // Converts spherical coordinates (degrees) to 3D Cartesian.\n\n\nfunction cartesian(coordinates) {\n  var lambda = coordinates[0] * radians,\n      phi = coordinates[1] * radians,\n      cosphi = cos(phi);\n  return [cosphi * cos(lambda), cosphi * sin(lambda), sin(phi)];\n}","import { geoCentroid as centroid, geoGnomonic as gnomonic, geoDistance as distance } from \"d3-geo\";\nimport { degrees } from \"../math.js\";\nimport polyhedral from \"./index.js\";\nexport default function (parents, polygons, faceProjection, find) {\n  parents = parents || [];\n  polygons = polygons || {\n    features: []\n  };\n  find = find || find0; // it is possible to pass a specific projection on each face\n  // by default is is a gnomonic projection centered on the face's centroid\n  // scale 1 by convention\n\n  faceProjection = faceProjection || function (face) {\n    return gnomonic().scale(1).translate([0, 0]).rotate([-face.site[0], -face.site[1]]);\n  };\n\n  var faces = [];\n\n  function build_tree() {\n    // the faces from the polyhedron each yield\n    // - face: its vertices\n    // - site: its voronoi site (default: centroid)\n    // - project: local projection on this face\n    faces = polygons.features.map(function (feature, i) {\n      var polygon = feature.geometry.coordinates[0];\n      var face = polygon.slice(0, -1);\n      face.site = feature.properties && feature.properties.sitecoordinates ? feature.properties.sitecoordinates : centroid(feature.geometry);\n      return {\n        face: face,\n        site: face.site,\n        id: i,\n        project: faceProjection(face)\n      };\n    }); // Build a tree of the faces, starting with face 0 (North Pole)\n    // which has no parent (-1)\n\n    parents.forEach(function (d, i) {\n      var node = faces[d];\n      node && (node.children || (node.children = [])).push(faces[i]);\n    });\n  } // a basic function to find the polygon that contains the point\n\n\n  function find0(lambda, phi) {\n    var d0 = Infinity;\n    var found = -1;\n\n    for (var i = 0; i < faces.length; i++) {\n      var d = distance(faces[i].site, [lambda, phi]);\n\n      if (d < d0) {\n        d0 = d;\n        found = i;\n      }\n    }\n\n    return found;\n  }\n\n  function faceFind(lambda, phi) {\n    return faces[find(lambda * degrees, phi * degrees)];\n  }\n\n  var p = gnomonic();\n\n  function reset() {\n    var rotate = p.rotate(),\n        translate = p.translate(),\n        center = p.center(),\n        scale = p.scale(),\n        angle = p.angle();\n\n    if (faces.length) {\n      p = polyhedral(faces[0], faceFind);\n    }\n\n    p.parents = function (_) {\n      if (!arguments.length) return parents;\n      parents = _;\n      build_tree();\n      return reset();\n    };\n\n    p.polygons = function (_) {\n      if (!arguments.length) return polygons;\n      polygons = _;\n      build_tree();\n      return reset();\n    };\n\n    p.faceProjection = function (_) {\n      if (!arguments.length) return faceProjection;\n      faceProjection = _;\n      build_tree();\n      return reset();\n    };\n\n    p.faceFind = function (_) {\n      if (!arguments.length) return find;\n      find = _;\n      return reset();\n    };\n\n    return p.rotate(rotate).translate(translate).center(center).scale(scale).angle(angle);\n  }\n\n  build_tree();\n  return reset();\n}","import { acos, asin, degrees, sqrt } from \"../math.js\";\nimport voronoi from \"./voronoi.js\";\nexport default function () {\n  var A0 = asin(1 / sqrt(3)) * degrees,\n      A1 = acos((sqrt(5) - 1) / sqrt(3) / 2) * degrees,\n      A2 = 90 - A1,\n      A3 = acos(-(1 + sqrt(5)) / sqrt(3) / 2) * degrees;\n  var dodecahedron = [[[45, A0], [0, A1], [180, A1], [135, A0], [90, A2]], [[45, A0], [A2, 0], [-A2, 0], [-45, A0], [0, A1]], [[45, A0], [90, A2], [90, -A2], [45, -A0], [A2, 0]], [[0, A1], [-45, A0], [-90, A2], [-135, A0], [180, A1]], [[A2, 0], [45, -A0], [0, -A1], [-45, -A0], [-A2, 0]], [[90, A2], [135, A0], [A3, 0], [135, -A0], [90, -A2]], [[45, -A0], [90, -A2], [135, -A0], [180, -A1], [0, -A1]], [[135, A0], [180, A1], [-135, A0], [-A3, 0], [A3, 0]], [[-45, A0], [-A2, 0], [-45, -A0], [-90, -A2], [-90, A2]], [[-45, -A0], [0, -A1], [180, -A1], [-135, -A0], [-90, -A2]], [[135, -A0], [A3, 0], [-A3, 0], [-135, -A0], [180, -A1]], [[-135, A0], [-90, A2], [-90, -A2], [-135, -A0], [-A3, 0]]];\n  var polygons = {\n    type: \"FeatureCollection\",\n    features: dodecahedron.map(function (face) {\n      face.push(face[0]);\n      return {\n        geometry: {\n          type: \"Polygon\",\n          coordinates: [face]\n        }\n      };\n    })\n  };\n  return voronoi().parents([-1, 0, 4, 8, 1, 2, 2, 3, 1, 8, 6, 3]).angle(72 * 1.5).polygons(polygons).scale(99.8).rotate([-8, 0, -32]);\n}","export default function (a, b) {\n  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n}","import _createForOfIteratorHelper from \"/Users/linying/codespace/Lyzzz-s-Blog/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport ascending from \"./ascending.js\";\nimport minIndex from \"./minIndex.js\";\nexport default function leastIndex(values) {\n  var compare = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ascending;\n  if (compare.length === 1) return minIndex(values, compare);\n  var minValue;\n  var min = -1;\n  var index = -1;\n\n  var _iterator = _createForOfIteratorHelper(values),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var value = _step.value;\n      ++index;\n\n      if (min < 0 ? compare(value, value) === 0 : compare(value, minValue) < 0) {\n        minValue = value;\n        min = index;\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return min;\n}","import _createForOfIteratorHelper from \"/Users/linying/codespace/Lyzzz-s-Blog/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nexport default function minIndex(values, valueof) {\n  var min;\n  var minIndex = -1;\n  var index = -1;\n\n  if (valueof === undefined) {\n    var _iterator = _createForOfIteratorHelper(values),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var value = _step.value;\n        ++index;\n\n        if (value != null && (min > value || min === undefined && value >= value)) {\n          min = value, minIndex = index;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  } else {\n    var _iterator2 = _createForOfIteratorHelper(values),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _value = _step2.value;\n\n        if ((_value = valueof(_value, ++index, values)) != null && (min > _value || min === undefined && _value >= _value)) {\n          min = _value, minIndex = index;\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  return minIndex;\n}","import leastIndex from \"./leastIndex.js\";\nexport default function scan(values, compare) {\n  var index = leastIndex(values, compare);\n  return index < 0 ? undefined : index;\n}","// code duplicated from d3-geo-projection\nimport { abs, asin, atan2, cos, epsilon, halfPi, pow, sign, sin } from \"./math.js\";\nexport function lagrangeRaw(n) {\n  function forward(lambda, phi) {\n    if (abs(abs(phi) - halfPi) < epsilon) return [0, phi < 0 ? -2 : 2];\n    var sinPhi = sin(phi),\n        v = pow((1 + sinPhi) / (1 - sinPhi), n / 2),\n        c = 0.5 * (v + 1 / v) + cos(lambda *= n);\n    return [2 * sin(lambda) / c, (v - 1 / v) / c];\n  }\n\n  forward.invert = function (x, y) {\n    var y0 = abs(y);\n    if (abs(y0 - 2) < epsilon) return x ? null : [0, sign(y) * halfPi];\n    if (y0 > 2) return null;\n    x /= 2, y /= 2;\n    var x2 = x * x,\n        y2 = y * y,\n        t = 2 * y / (1 + x2 + y2); // tanh(nPhi)\n\n    t = pow((1 + t) / (1 - t), 1 / n);\n    return [atan2(2 * x, 1 - x2 - y2) / n, asin((t - 1) / (t + 1))];\n  };\n\n  return forward;\n}","import { abs, atan2, cos, exp, halfPi, log, pow, sin, sqrt } from \"./math.js\";\nexport function complexAtan(x, y) {\n  var x2 = x * x,\n      y_1 = y + 1,\n      t = 1 - x2 - y * y;\n  return [0.5 * ((x >= 0 ? halfPi : -halfPi) - atan2(t, 2 * x)), -0.25 * log(t * t + 4 * x2) + 0.5 * log(y_1 * y_1 + x2)];\n}\nexport function complexDivide(a, b) {\n  if (b[1]) a = complexMul(a, [b[0], -b[1]]), b = complexNorm2(b);else b = b[0];\n  return [a[0] / b, a[1] / b];\n}\nexport function complexMul(a, b) {\n  return [a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]];\n}\nexport function complexAdd(a, b) {\n  return [a[0] + b[0], a[1] + b[1]];\n}\nexport function complexSub(a, b) {\n  return [a[0] - b[0], a[1] - b[1]];\n}\nexport function complexNorm2(a) {\n  return a[0] * a[0] + a[1] * a[1];\n}\nexport function complexNorm(a) {\n  return sqrt(complexNorm2(a));\n}\nexport function complexLogHypot(a, b) {\n  var _a = abs(a),\n      _b = abs(b);\n\n  if (a === 0) return log(_b);\n  if (b === 0) return log(_a);\n  if (_a < 3000 && _b < 3000) return log(a * a + b * b) * 0.5;\n  return log(a / cos(atan2(b, a)));\n} // adapted from https://github.com/infusion/Complex.js\n\nexport function complexPow(a, n) {\n  var b = a[1],\n      arg,\n      loh;\n  a = a[0];\n  if (a === 0 && b === 0) return [0, 0];\n  if (typeof n === \"number\") n = [n, 0];\n\n  if (!n[1]) {\n    if (b === 0 && a >= 0) {\n      return [pow(a, n[0]), 0];\n    } else if (a === 0) {\n      switch ((n[1] % 4 + 4) % 4) {\n        case 0:\n          return [pow(b, n[0]), 0];\n\n        case 1:\n          return [0, pow(b, n[0])];\n\n        case 2:\n          return [-pow(b, n[0]), 0];\n\n        case 3:\n          return [0, -pow(b, n[0])];\n      }\n    }\n  }\n\n  arg = atan2(b, a);\n  loh = complexLogHypot(a, b);\n  a = exp(n[0] * loh - n[1] * arg);\n  b = n[1] * loh + n[0] * arg;\n  return [a * cos(b), a * sin(b)];\n}","import { geoProjection as projection, geoStream } from \"d3-geo\";\nimport { scan } from \"d3-array\";\nimport { asin, degrees, epsilon, sqrt } from \"./math.js\";\nimport { lagrangeRaw } from \"./lagrange.js\";\nimport { complexAdd, complexMul, complexNorm2, complexPow } from \"./complex.js\"; // w1 = gamma(1/n) * gamma(1 - 2/n) / n / gamma(1 - 1/n)\n// https://bl.ocks.org/Fil/852557838117687bbd985e4b38ff77d4\n\nvar w = [-1 / 2, sqrt(3) / 2],\n    w1 = [1.7666387502854533, 0],\n    m = 0.3 * 0.3; // Approximate \\int _0 ^sm(z)  dt / (1 - t^3)^(2/3)\n// sm maps a triangle to a disc, sm^-1 does the opposite\n\nfunction sm_1(z) {\n  var k = [0, 0]; // rotate to have s ~= 1\n\n  var rot = complexPow(w, scan([0, 1, 2].map(function (i) {\n    return -complexMul(z, complexPow(w, [i, 0]))[0];\n  })));\n  var y = complexMul(rot, z);\n  y = [1 - y[0], -y[1]]; // McIlroy formula 5 p6 and table for F3 page 16\n\n  var F0 = [1.44224957030741, 0.240374928384568, 0.0686785509670194, 0.0178055502507087, 0.00228276285265497, -1.48379585422573e-3, -1.64287728109203e-3, -1.02583417082273e-3, -4.83607537673571e-4, -1.67030822094781e-4, -2.45024395166263e-5, 2.14092375450951e-5, 2.55897270486771e-5, 1.73086854400834e-5, 8.72756299984649e-6, 3.18304486798473e-6, 4.79323894565283e-7, -4.58968389565456e-7, -5.62970586787826e-7, -3.92135372833465e-7];\n  var F = [0, 0];\n\n  for (var i = F0.length; i--;) {\n    F = complexAdd([F0[i], 0], complexMul(F, y));\n  }\n\n  k = complexMul(complexAdd(w1, complexMul([-F[0], -F[1]], complexPow(y, 1 - 2 / 3))), complexMul(rot, rot)); // when we are close to [0,0] we switch to another approximation:\n  // https://www.wolframalpha.com/input/?i=(-2%2F3+choose+k)++*+(-1)%5Ek++%2F+(k%2B1)+with+k%3D0,1,2,3,4\n  // the difference is _very_ tiny but necessary\n  // if we want projection(0,0) === [0,0]\n\n  var n = complexNorm2(z);\n\n  if (n < m) {\n    var H0 = [1, 1 / 3, 5 / 27, 10 / 81, 22 / 243 //\n    ];\n    var z3 = complexPow(z, [3, 0]);\n    var h = [0, 0];\n\n    for (i = H0.length; i--;) {\n      h = complexAdd([H0[i], 0], complexMul(h, z3));\n    }\n\n    h = complexMul(h, z);\n    k = complexAdd(complexMul(k, [n / m, 0]), complexMul(h, [1 - n / m, 0]));\n  }\n\n  return k;\n}\n\nvar lagrange1_2 = lagrangeRaw ? lagrangeRaw(0.5) : null;\nexport function coxRaw(lambda, phi) {\n  var s = lagrange1_2(lambda, phi);\n  var t = sm_1([s[1] / 2, s[0] / 2]);\n  return [t[1], t[0]];\n} // the Sphere should go *exactly* to the vertices of the triangles\n// because they are singular points\n\nfunction sphere() {\n  var c = 2 * asin(1 / sqrt(5)) * degrees;\n  return {\n    type: \"Polygon\",\n    coordinates: [[[0, 90], [-180, -c + epsilon], [0, -90], [180, -c + epsilon], [0, 90]]]\n  };\n}\n\nexport default function () {\n  var p = projection(coxRaw);\n  var stream_ = p.stream;\n\n  p.stream = function (stream) {\n    var rotate = p.rotate(),\n        rotateStream = stream_(stream),\n        sphereStream = (p.rotate([0, 0]), stream_(stream));\n    p.rotate(rotate);\n\n    rotateStream.sphere = function () {\n      geoStream(sphere(), sphereStream);\n    };\n\n    return rotateStream;\n  };\n\n  return p.scale(188.305).translate([480, 333.167]);\n}","import { abs, epsilon, epsilon2 } from \"./math.js\"; // Approximate Newton-Raphson\n// Solve f(x) = y, start from x\n\nexport function solve(f, y, x) {\n  var steps = 100,\n      delta,\n      f0,\n      f1;\n  x = x === undefined ? 0 : +x;\n  y = +y;\n\n  do {\n    f0 = f(x);\n    f1 = f(x + epsilon);\n    if (f0 === f1) f1 = f0 + epsilon;\n    x -= delta = -1 * epsilon * (f0 - y) / (f0 - f1);\n  } while (steps-- > 0 && abs(delta) > epsilon);\n\n  return steps < 0 ? NaN : x;\n} // Approximate Newton-Raphson in 2D\n// Solve f(a,b) = [x,y]\n\nexport function solve2d(f) {\n  var MAX_ITERATIONS = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 40;\n  var eps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : epsilon2;\n  return function (x, y) {\n    var a = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var b = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var err2, da, db;\n\n    for (var i = 0; i < MAX_ITERATIONS; i++) {\n      var p = f(a, b),\n          // diffs\n      tx = p[0] - x,\n          ty = p[1] - y;\n      if (abs(tx) < eps && abs(ty) < eps) break; // we're there!\n      // backtrack if we overshot\n\n      var h = tx * tx + ty * ty;\n\n      if (h > err2) {\n        a -= da /= 2;\n        b -= db /= 2;\n        continue;\n      }\n\n      err2 = h; // partial derivatives\n\n      var ea = (a > 0 ? -1 : 1) * eps,\n          eb = (b > 0 ? -1 : 1) * eps,\n          pa = f(a + ea, b),\n          pb = f(a, b + eb),\n          dxa = (pa[0] - p[0]) / ea,\n          dya = (pa[1] - p[1]) / ea,\n          dxb = (pb[0] - p[0]) / eb,\n          dyb = (pb[1] - p[1]) / eb,\n          // determinant\n      D = dyb * dxa - dya * dxb,\n          // newton step  or half-step for small D\n      l = (abs(D) < 0.5 ? 0.5 : 1) / D;\n      da = (ty * dxb - tx * dyb) * l;\n      db = (tx * dya - ty * dxa) * l;\n      a += da;\n      b += db;\n      if (abs(da) < eps && abs(db) < eps) break; // we're crawling\n    }\n\n    return [a, b];\n  };\n}","import { geoProjection as projection, geoStereographicRaw, geoCentroid, geoContains } from \"d3-geo\";\nimport polyhedral from \"./polyhedral/index.js\";\nimport { scan } from \"d3-array\";\nimport { abs, asin, degrees, sqrt } from \"./math.js\";\nimport { complexAdd, complexMul, complexNorm, complexPow, complexSub } from \"./complex\";\nimport { solve2d } from \"./newton.js\";\nexport function leeRaw(lambda, phi) {\n  // return d3.geoGnomonicRaw(...arguments);\n  var w = [-1 / 2, sqrt(3) / 2],\n      k = [0, 0],\n      h = [0, 0],\n      i,\n      z = complexMul(geoStereographicRaw(lambda, phi), [sqrt(2), 0]); // rotate to have s ~= 1\n\n  var sector = scan([0, 1, 2].map(function (i) {\n    return -complexMul(z, complexPow(w, [i, 0]))[0];\n  }));\n  var rot = complexPow(w, [sector, 0]);\n  var n = complexNorm(z);\n\n  if (n > 0.3) {\n    // if |z| > 0.5, use the approx based on y = (1-z)\n    // McIlroy formula 6 p6 and table for G page 16\n    var y = complexSub([1, 0], complexMul(rot, z)); // w1 = gamma(1/3) * gamma(1/2) / 3 / gamma(5/6);\n    // https://bl.ocks.org/Fil/1aeff1cfda7188e9fbf037d8e466c95c\n\n    var w1 = 1.4021821053254548;\n    var G0 = [1.15470053837925, 0.192450089729875, 0.0481125224324687, 0.010309826235529, 3.34114739114366e-4, -1.50351632601465e-3, -1.2304417796231e-3, -6.75190201960282e-4, -2.84084537293856e-4, -8.21205120500051e-5, -1.59257630018706e-6, 1.91691805888369e-5, 1.73095888028726e-5, 1.03865580818367e-5, 4.70614523937179e-6, 1.4413500104181e-6, 1.92757960170179e-8, -3.82869799649063e-7, -3.57526015225576e-7, -2.2175964844211e-7];\n    var G = [0, 0];\n\n    for (i = G0.length; i--;) {\n      G = complexAdd([G0[i], 0], complexMul(G, y));\n    }\n\n    k = complexSub([w1, 0], complexMul(complexPow(y, 1 / 2), G));\n    k = complexMul(k, rot);\n    k = complexMul(k, rot);\n  }\n\n  if (n < 0.5) {\n    // if |z| < 0.3\n    // https://www.wolframalpha.com/input/?i=series+of+((1-z%5E3))+%5E+(-1%2F2)+at+z%3D0 (and ask for \"more terms\")\n    // 1 + z^3/2 + (3 z^6)/8 + (5 z^9)/16 + (35 z^12)/128 + (63 z^15)/256 + (231 z^18)/1024 + O(z^21)\n    // https://www.wolframalpha.com/input/?i=integral+of+1+%2B+z%5E3%2F2+%2B+(3+z%5E6)%2F8+%2B+(5+z%5E9)%2F16+%2B+(35+z%5E12)%2F128+%2B+(63+z%5E15)%2F256+%2B+(231+z%5E18)%2F1024\n    // (231 z^19)/19456 + (63 z^16)/4096 + (35 z^13)/1664 + z^10/32 + (3 z^7)/56 + z^4/8 + z + constant\n    var H0 = [1, 1 / 8, 3 / 56, 1 / 32, 35 / 1664, 63 / 4096, 231 / 19456];\n    var z3 = complexPow(z, [3, 0]);\n\n    for (i = H0.length; i--;) {\n      h = complexAdd([H0[i], 0], complexMul(h, z3));\n    }\n\n    h = complexMul(h, z);\n  }\n\n  if (n < 0.3) return h;\n  if (n > 0.5) return k; // in between 0.3 and 0.5, interpolate\n\n  var t = (n - 0.3) / (0.5 - 0.3);\n  return complexAdd(complexMul(k, [t, 0]), complexMul(h, [1 - t, 0]));\n}\nvar leeSolver = solve2d(leeRaw);\n\nleeRaw.invert = function (x, y) {\n  if (x > 1.5) return false; // immediately avoid using the wrong face\n\n  var p = leeSolver(x, y, x, y * 0.5),\n      q = leeRaw(p[0], p[1]);\n  q[0] -= x;\n  q[1] -= y;\n  if (q[0] * q[0] + q[1] * q[1] < 1e-8) return p;\n  return [-10, 0]; // far out of the face\n};\n\nvar asin1_3 = asin(1 / 3);\nvar centers = [[0, 90], [-180, -asin1_3 * degrees], [-60, -asin1_3 * degrees], [60, -asin1_3 * degrees]];\nvar tetrahedron = [[1, 2, 3], [0, 2, 1], [0, 3, 2], [0, 1, 3]].map(function (face) {\n  return face.map(function (i) {\n    return centers[i];\n  });\n});\nexport default function () {\n  var faceProjection = function faceProjection(face) {\n    var c = geoCentroid({\n      type: \"MultiPoint\",\n      coordinates: face\n    }),\n        rotate = [-c[0], -c[1], 30];\n\n    if (abs(c[1]) == 90) {\n      rotate = [0, -c[1], -30];\n    }\n\n    return projection(leeRaw).scale(1).translate([0, 0]).rotate(rotate);\n  };\n\n  var faces = tetrahedron.map(function (face) {\n    return {\n      face: face,\n      project: faceProjection(face)\n    };\n  });\n  [-1, 0, 0, 0].forEach(function (d, i) {\n    var node = faces[d];\n    node && (node.children || (node.children = [])).push(faces[i]);\n  });\n  var p = polyhedral(faces[0], function (lambda, phi) {\n    lambda *= degrees;\n    phi *= degrees;\n\n    for (var i = 0; i < faces.length; i++) {\n      if (geoContains({\n        type: \"Polygon\",\n        coordinates: [[tetrahedron[i][0], tetrahedron[i][1], tetrahedron[i][2], tetrahedron[i][0]]]\n      }, [lambda, phi])) {\n        return faces[i];\n      }\n    }\n  });\n  return p.rotate([30, 180]) // North Pole aspect, needs clipPolygon\n  // .rotate([-30, 0]) // South Pole aspect\n  .angle(30).scale(118.662).translate([480, 195.47]);\n}","/*\n * Buckminster Fullers spherical triangle transformation procedure\n *\n * Based on Robert W. Grays formulae published in Exact Transformation Equations\n * For Fuller's World Map, _Cartographica_, 32(3): 17-25 (1995).\n *\n * Implemented for D3.js by Philippe Rivire, 2018 (https://visionscarto.net/)\n *\n * To the extent possible under law, Philippe Rivire has waived all copyright\n * and related or neighboring rights to this implementation. (Public Domain.)\n */\nimport { abs, atan2, cos, epsilon, sin, sqrt } from \"./math.js\";\nimport { geoGnomonicRaw as gnomonicRaw } from \"d3-geo\";\nexport default function GrayFullerRaw() {\n  var SQRT_3 = sqrt(3); // Grays constants\n\n  var Z = sqrt(5 + 2 * sqrt(5)) / sqrt(15),\n      el = sqrt(8) / sqrt(5 + sqrt(5)),\n      dve = sqrt(3 + sqrt(5)) / sqrt(5 + sqrt(5));\n\n  var grayfuller = function grayfuller(lambda, phi) {\n    var cosPhi = cos(phi),\n        s = Z / (cosPhi * cos(lambda)),\n        x = cosPhi * sin(lambda) * s,\n        y = sin(phi) * s,\n        a1p = atan2(2 * y / SQRT_3 + el / 3 - el / 2, dve),\n        a2p = atan2(x - y / SQRT_3 + el / 3 - el / 2, dve),\n        a3p = atan2(el / 3 - x - y / SQRT_3 - el / 2, dve);\n    return [SQRT_3 * (a2p - a3p), 2 * a1p - a2p - a3p];\n  }; // Inverse approximation\n\n\n  grayfuller.invert = function (x, y) {\n    // if the point is out of the triangle, return\n    // something meaningless (but far away enough)\n    if (x * x + y * y > 5) return [0, 3];\n    var R = 2.9309936378128416,\n        p = gnomonicRaw.invert(x / R, y / R);\n    var j = 0;\n\n    do {\n      var f = grayfuller(p[0], p[1]),\n          dx = x - f[0],\n          dy = y - f[1];\n      p[0] += 0.2 * dx;\n      p[1] += 0.2 * dy;\n    } while (j++ < 30 && abs(dx) + abs(dy) > epsilon);\n\n    return p;\n  };\n\n  return grayfuller;\n}","export default function (start, stop, step) {\n  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;\n  var i = -1,\n      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,\n      range = new Array(n);\n\n  while (++i < n) {\n    range[i] = start + i * step;\n  }\n\n  return range;\n}","/*\n * Buckminster Fullers AirOcean arrangement of the icosahedron\n *\n * Implemented for D3.js by Jason Davies (2013),\n * Enrico Spinielli (2017) and Philippe Rivire (2017, 2018)\n *\n */\nimport { atan, degrees } from \"./math.js\";\nimport polyhedral from \"./polyhedral/index.js\";\nimport { default as grayFullerRaw } from \"./grayfuller.js\";\nimport { geoCentroid as centroid, geoContains as _contains, geoGnomonic as gnomonic, geoProjection as projection } from \"d3-geo\";\nimport { range } from \"d3-array\";\n\nfunction airoceanRaw(faceProjection) {\n  var theta = atan(0.5) * degrees; // construction inspired by\n  // https://en.wikipedia.org/wiki/Regular_icosahedron#Spherical_coordinates\n\n  var vertices = [[0, 90], [0, -90]].concat(range(10).map(function (i) {\n    var phi = (i * 36 + 180) % 360 - 180;\n    return [phi, i & 1 ? theta : -theta];\n  })); // icosahedron\n\n  var polyhedron = [[0, 3, 11], [0, 5, 3], [0, 7, 5], [0, 9, 7], [0, 11, 9], // North\n  [2, 11, 3], [3, 4, 2], [4, 3, 5], [5, 6, 4], [6, 5, 7], [7, 8, 6], [8, 7, 9], [9, 10, 8], [10, 9, 11], [11, 2, 10], // Equator\n  [1, 2, 4], [1, 4, 6], [1, 6, 8], [1, 8, 10], [1, 10, 2] // South\n  ].map(function (face) {\n    return face.map(function (i) {\n      return vertices[i];\n    });\n  }); // add centroid\n\n  polyhedron.forEach(function (face) {\n    face.centroid = centroid({\n      type: \"MultiPoint\",\n      coordinates: face\n    });\n  }); // split the relevant faces:\n  // * face[15] in the centroid: this will become face[15], face[20] and face[21]\n  // * face[14] in the middle of the side: this will become face[14] and face[22]\n\n  (function () {\n    var face, tmp, mid, centroid; // Split face[15] in 3 faces at centroid.\n\n    face = polyhedron[15];\n    centroid = face.centroid;\n    tmp = face.slice();\n    face[0] = centroid; // (new) face[15]\n\n    face = [tmp[0], centroid, tmp[2]];\n    face.centroid = centroid;\n    polyhedron.push(face); // face[20]\n\n    face = [tmp[0], tmp[1], centroid];\n    face.centroid = centroid;\n    polyhedron.push(face); // face[21]\n    // Split face 14 at the edge.\n\n    face = polyhedron[14];\n    centroid = face.centroid;\n    tmp = face.slice(); // compute planar midpoint\n\n    var proj = gnomonic().scale(1).translate([0, 0]).rotate([-centroid[0], -centroid[1]]);\n    var a = proj(face[1]),\n        b = proj(face[2]);\n    mid = proj.invert([(a[0] + b[0]) / 2, (a[1] + b[1]) / 2]);\n    face[1] = mid; // (new) face[14]\n    // build the new half face\n\n    face = [tmp[0], tmp[1], mid];\n    face.centroid = centroid; // use original face[14] centroid\n\n    polyhedron.push(face); // face[22]\n    // cut face 19 to connect to 22\n\n    face = polyhedron[19];\n    centroid = face.centroid;\n    tmp = face.slice();\n    face[1] = mid; // build the new half face\n\n    face = [mid, tmp[0], tmp[1]];\n    face.centroid = centroid;\n    polyhedron.push(face); // face[23]\n  })();\n\n  var airocean = function airocean(faceProjection) {\n    faceProjection = faceProjection || function (face) {\n      // for half-triangles this is definitely not centroid({type: \"MultiPoint\", coordinates: face});\n      var c = face.centroid;\n      return gnomonic().scale(1).translate([0, 0]).rotate([-c[0], -c[1]]);\n    };\n\n    var faces = polyhedron.map(function (face, i) {\n      var polygon = face.slice();\n      polygon.push(polygon[0]);\n      return {\n        face: face,\n        site: face.centroid,\n        id: i,\n        contains: function contains(lambda, phi) {\n          return _contains({\n            type: \"Polygon\",\n            coordinates: [polygon]\n          }, [lambda * degrees, phi * degrees]);\n        },\n        project: faceProjection(face)\n      };\n    }); // Connect each face to a parent face.\n\n    var parents = [// N\n    -1, // 0\n    0, // 1\n    1, // 2\n    11, // 3\n    13, // 4\n    // Eq\n    6, // 5\n    7, // 6\n    1, // 7\n    7, // 8\n    8, // 9\n    9, // 10\n    10, // 11\n    11, // 12\n    12, // 13\n    13, // 14\n    // S\n    6, // 15\n    8, // 16\n    10, // 17\n    17, // 18\n    21, // 19\n    16, // 20\n    15, // 21\n    19, // 22\n    19 // 23\n    ];\n    parents.forEach(function (d, i) {\n      var node = faces[d];\n      node && (node.children || (node.children = [])).push(faces[i]);\n    });\n\n    function face(lambda, phi) {\n      for (var i = 0; i < faces.length; i++) {\n        if (faces[i].contains(lambda, phi)) return faces[i];\n      }\n    } // Polyhedral projection\n\n\n    var proj = polyhedral(faces[0], // the root face\n    face // a function that returns a face given coords\n    );\n    proj.faces = faces;\n    return proj;\n  };\n\n  return airocean(faceProjection);\n}\n\nexport default function () {\n  var p = airoceanRaw(function (face) {\n    var c = face.centroid;\n    face.direction = Math.abs(c[1] - 52.62) < 1 || Math.abs(c[1] + 10.81) < 1 ? 0 : 60;\n    return projection(grayFullerRaw()).scale(1).translate([0, 0]).rotate([-c[0], -c[1], face.direction || 0]);\n  });\n  return p.rotate([-83.65929, 25.44458, -87.45184]).angle(-60).scale(45.4631).center([126, 0]);\n}","/*\n * Icosahedral map\n *\n * Implemented for D3.js by Jason Davies (2013),\n * Enrico Spinielli (2017) and Philippe Rivire (2017, 2018)\n *\n */\nimport { atan, degrees } from \"./math.js\";\nimport voronoi from \"./polyhedral/voronoi.js\";\nexport default function () {\n  var theta = atan(0.5) * degrees; // construction inspired by\n  // https://en.wikipedia.org/wiki/Regular_icosahedron#Spherical_coordinates\n\n  var vertices = [[0, 90], [0, -90]].concat([0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(function (i) {\n    var phi = (i * 36 + 180) % 360 - 180;\n    return [phi, i & 1 ? theta : -theta];\n  })); // icosahedron\n\n  var polyhedron = [[0, 3, 11], [0, 5, 3], [0, 7, 5], [0, 9, 7], [0, 11, 9], // North\n  [2, 11, 3], [3, 4, 2], [4, 3, 5], [5, 6, 4], [6, 5, 7], [7, 8, 6], [8, 7, 9], [9, 10, 8], [10, 9, 11], [11, 2, 10], // Equator\n  [1, 2, 4], [1, 4, 6], [1, 6, 8], [1, 8, 10], [1, 10, 2] // South\n  ].map(function (face) {\n    return face.map(function (i) {\n      return vertices[i];\n    });\n  });\n  var polygons = {\n    type: \"FeatureCollection\",\n    features: polyhedron.map(function (face) {\n      face.push(face[0]);\n      return {\n        geometry: {\n          type: \"Polygon\",\n          coordinates: [face]\n        }\n      };\n    })\n  };\n  var parents = [// N\n  -1, // 0\n  7, // 1\n  9, // 2\n  11, // 3\n  13, // 4\n  // Eq\n  0, // 5\n  5, // 6\n  6, // 7\n  7, // 8\n  8, // 9\n  9, // 10\n  10, // 11\n  11, // 12\n  12, // 13\n  13, // 14\n  // S\n  6, // 15\n  8, // 16\n  10, // 17\n  12, // 18\n  14 // 19\n  ];\n  return voronoi().parents(parents).angle(0).polygons(polygons).rotate([108, 0]).scale(131.777).center([162, 0]);\n}\n/*\n    // Jarke J. van Wijk, \"Unfolding the Earth: Myriahedral Projections\",\n    // The Cartographic Journal Vol. 45 No. 1 pp. 3242 February 2008, fig. 8\n    // https://bl.ocks.org/espinielli/475f5fde42a5513ab7eba3f53033ea9e\n    d3.geoIcosahedral().parents([-1,0,1,11,3,0,7,1,7,8,9,10,11,12,13,6,8,10,19,15])\n   .angle(-60)\n   .rotate([-83.65929, 25.44458, -87.45184])\n*/","import _createForOfIteratorHelper from \"/Users/linying/codespace/Lyzzz-s-Blog/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\n\n/*\n * Imago projection, by Justin Kunimune\n *\n * Inspired by Hajime Narukawas AuthaGraph\n *\n */\nimport { abs, acos, asin, atan, atan2, cos, degrees, epsilon, floor, halfPi, pi, pow, sign, sin, sqrt, tan } from \"./math\";\nimport { geoProjectionMutator as projectionMutator } from \"d3-geo\";\nimport { default as clipPolygon } from \"./clip/polygon.js\";\nimport { solve } from \"./newton.js\";\nvar hypot = Math.hypot;\nvar ASIN_ONE_THD = asin(1 / 3),\n    centrums = [[halfPi, 0, 0, -halfPi, 0, sqrt(3)], [-ASIN_ONE_THD, 0, pi, halfPi, 0, -sqrt(3)], [-ASIN_ONE_THD, 2 * pi / 3, pi, 5 * pi / 6, 3, 0], [-ASIN_ONE_THD, -2 * pi / 3, pi, pi / 6, -3, 0]],\n    TETRAHEDRON_WIDE_VERTEX = {\n  sphereSym: 3,\n  planarSym: 6,\n  width: 6,\n  height: 2 * sqrt(3),\n  centrums: centrums,\n  rotateOOB: function rotateOOB(x, y, xCen, yCen) {\n    yCen * 0;\n    if (abs(x) > this.width / 2) return [2 * xCen - x, -y];else return [-x, this.height * sign(y) - y];\n  },\n  inBounds: function inBounds() {\n    return true;\n  }\n},\n    configuration = TETRAHEDRON_WIDE_VERTEX;\nexport function imagoRaw(k) {\n  function faceProject(lon, lat) {\n    var tht = atan((lon - asin(sin(lon) / sqrt(3))) / pi * sqrt(12)),\n        p = (halfPi - lat) / atan(sqrt(2) / cos(lon));\n    return [pow(p, k) * sqrt(3) / cos(tht), tht];\n  }\n\n  function faceInverse(r, th) {\n    var l = solve(function (l) {\n      return atan((l - asin(sin(l) / sqrt(3))) / pi * sqrt(12));\n    }, th, th / 2),\n        R = r / (sqrt(3) / cos(th));\n    return [halfPi - pow(R, 1 / k) * atan(sqrt(2) / cos(l)), l];\n  }\n\n  function obliquifySphc(latF, lonF, pole) {\n    if (pole == null) // null pole indicates that this procedure should be bypassed\n      return [latF, lonF];\n    var lat0 = pole[0],\n        lon0 = pole[1],\n        tht0 = pole[2];\n    var lat1, lon1;\n    if (lat0 == halfPi) lat1 = latF;else lat1 = asin(sin(lat0) * sin(latF) + cos(lat0) * cos(latF) * cos(lon0 - lonF)); // relative latitude\n\n    if (lat0 == halfPi) // accounts for all the 0/0 errors at the poles\n      lon1 = lonF - lon0;else if (lat0 == -halfPi) lon1 = lon0 - lonF - pi;else {\n      lon1 = acos((cos(lat0) * sin(latF) - sin(lat0) * cos(latF) * cos(lon0 - lonF)) / cos(lat1)) - pi; // relative longitude\n\n      if (isNaN(lon1)) {\n        if (cos(lon0 - lonF) >= 0 && latF < lat0 || cos(lon0 - lonF) < 0 && latF < -lat0) lon1 = 0;else lon1 = -pi;\n      } else if (sin(lonF - lon0) > 0) // it's a plus-or-minus arccos.\n        lon1 = -lon1;\n    }\n    lon1 = lon1 - tht0;\n    return [lat1, lon1];\n  }\n\n  function obliquifyPlnr(coords, pole) {\n    if (pole == null) //this indicates that you just shouldn't do this calculation\n      return coords;\n    var lat1 = coords[0],\n        lon1 = coords[1];\n    var lat0 = pole[0],\n        lon0 = pole[1],\n        tht0 = pole[2];\n    lon1 += tht0;\n    var latf = asin(sin(lat0) * sin(lat1) - cos(lat0) * cos(lon1) * cos(lat1)),\n        lonf,\n        innerFunc = sin(lat1) / cos(lat0) / cos(latf) - tan(lat0) * tan(latf);\n    if (lat0 == halfPi) // accounts for special case when lat0 = pi/2\n      lonf = lon1 + lon0;else if (lat0 == -halfPi) // accounts for special case when lat0 = -pi/2\n      lonf = -lon1 + lon0 + pi;else if (abs(innerFunc) > 1) {\n      // accounts for special case when cos(lat1) -> 0\n      if (lon1 == 0 && lat1 < -lat0 || lon1 != 0 && lat1 < lat0) lonf = lon0 + pi;else lonf = lon0;\n    } else if (sin(lon1) > 0) lonf = lon0 + acos(innerFunc);else lonf = lon0 - acos(innerFunc);\n    var thtf = pole[2];\n    return [latf, lonf, thtf];\n  }\n\n  function forward(lon, lat) {\n    var width = configuration.width,\n        height = configuration.height;\n    var numSym = configuration.sphereSym; //we're about to be using this variable a lot\n\n    var latR = -Infinity;\n    var lonR = -Infinity;\n    var centrum = null;\n\n    var _iterator = _createForOfIteratorHelper(centrums),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var testCentrum = _step.value;\n        //iterate through the centrums to see which goes here\n        var relCoords = obliquifySphc(lat, lon, testCentrum);\n\n        if (relCoords[0] > latR) {\n          latR = relCoords[0];\n          lonR = relCoords[1];\n          centrum = testCentrum;\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    var lonR0 = floor((lonR + pi / numSym) / (2 * pi / numSym)) * (2 * pi / numSym);\n    var rth = faceProject(lonR - lonR0, latR);\n    var r = rth[0];\n    var th = rth[1] + centrum[3] + lonR0 * numSym / configuration.planarSym;\n    var x0 = centrum[4];\n    var y0 = centrum[5];\n    var output = [r * cos(th) + x0, r * sin(th) + y0];\n\n    if (abs(output[0]) > width / 2 || abs(output[1]) > height / 2) {\n      output = configuration.rotateOOB(output[0], output[1], x0, y0);\n    }\n\n    return output;\n  }\n\n  function invert(x, y) {\n    if (isNaN(x) || isNaN(y)) return null;\n    if (!configuration.inBounds(x, y)) return null;\n    var numSym = configuration.planarSym;\n    var rM = +Infinity;\n    var centrum = null; //iterate to see which centrum we get\n\n    var _iterator2 = _createForOfIteratorHelper(centrums),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var testCentrum = _step2.value;\n        var rR = hypot(x - testCentrum[4], y - testCentrum[5]);\n\n        if (rR < rM) {\n          //pick the centrum that minimises r\n          rM = rR;\n          centrum = testCentrum;\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    var th0 = centrum[3],\n        x0 = centrum[4],\n        y0 = centrum[5],\n        r = hypot(x - x0, y - y0),\n        th = atan2(y - y0, x - x0) - th0,\n        thBase = floor((th + pi / numSym) / (2 * pi / numSym)) * (2 * pi / numSym);\n    var relCoords = faceInverse(r, th - thBase);\n    if (relCoords == null) return null;\n    relCoords[1] = thBase * numSym / configuration.sphereSym + relCoords[1];\n    var absCoords = obliquifyPlnr(relCoords, centrum);\n    return [absCoords[1], absCoords[0]];\n  }\n\n  forward.invert = invert;\n  return forward;\n}\nexport function imagoBlock() {\n  var k = 0.68,\n      m = projectionMutator(imagoRaw),\n      p = m(k);\n\n  p.k = function (_) {\n    return arguments.length ? m(k = +_) : k;\n  };\n\n  var a = -atan(1 / sqrt(2)) * degrees,\n      border = [[-180 + epsilon, a + epsilon], [0, 90], [180 - epsilon, a + epsilon], [180 - epsilon, a - epsilon], [-180 + epsilon, a - epsilon], [-180 + epsilon, a + epsilon]];\n  return p.preclip(clipPolygon({\n    type: \"Polygon\",\n    coordinates: [border]\n  })).scale(144.04).rotate([18, -12.5, 3.5]).center([0, 35.2644]);\n}\n\nfunction imagoWideRaw(k, shift) {\n  var imago = imagoRaw(k);\n  var height = configuration.height;\n\n  function forward(lon, lat) {\n    var p = imago(lon, lat),\n        q = [p[1], -p[0]];\n\n    if (q[1] > 0) {\n      q[0] = height - q[0];\n      q[1] *= -1;\n    }\n\n    q[0] += shift;\n    if (q[0] < 0) q[0] += height * 2;\n    return q;\n  }\n\n  function invert(x, y) {\n    x = (x - shift) / height;\n\n    if (x > 1.5) {\n      x -= 2;\n    }\n\n    if (x > 0.5) {\n      x = 1 - x;\n      y *= -1;\n    }\n\n    return imago.invert(-y, x * height);\n  }\n\n  forward.invert = invert;\n  return forward;\n}\n\nexport default function () {\n  var k = 0.59,\n      shift = 1.16,\n      m = projectionMutator(imagoWideRaw),\n      p = m(k, shift);\n\n  p.shift = function (_) {\n    return arguments.length ? clipped(m(k, shift = +_)) : shift;\n  };\n\n  p.k = function (_) {\n    return arguments.length ? clipped(m(k = +_, shift)) : k;\n  };\n\n  function clipped(p) {\n    var N = 100 + 2 * epsilon,\n        border = [],\n        e = 3e-3;\n    var scale = p.scale(),\n        center = p.center(),\n        translate = p.translate(),\n        rotate = p.rotate();\n    p.scale(1).center([0, 90]).rotate([0, 0]).translate([shift, 0]);\n\n    for (var i = N - epsilon; i > 0; i--) {\n      border.unshift(p.invert([1.5 * configuration.height - e, configuration.width / 2 * i / N]));\n      border.push(p.invert([-0.5 * configuration.height + e, configuration.width / 2 * i / N]));\n    }\n\n    border.push(border[0]);\n    return p.scale(scale).center(center).translate(translate).rotate(rotate).preclip(clipPolygon({\n      type: \"Polygon\",\n      coordinates: [border]\n    }));\n  }\n\n  return clipped(p).rotate([18, -12.5, 3.5]).scale(138.42).translate([480, 250]).center([-139.405, 40.5844]);\n}","import { atan, degrees, sqrt1_2 } from \"../math.js\";\nvar phi1 = atan(sqrt1_2) * degrees;\nvar cube = [[0, phi1], [90, phi1], [180, phi1], [-90, phi1], [0, -phi1], [90, -phi1], [180, -phi1], [-90, -phi1]];\nexport default [[0, 3, 2, 1], // N\n[0, 1, 5, 4], [1, 2, 6, 5], [2, 3, 7, 6], [3, 0, 4, 7], [4, 5, 6, 7] // S\n].map(function (face) {\n  return face.map(function (i) {\n    return cube[i];\n  });\n});","/*\n * Cubic map\n *\n * Implemented for D3.js by Enrico Spinielli (2017) and Philippe Rivire (2017, 2018)\n *\n */\nimport voronoi from \"./polyhedral/voronoi.js\";\nimport { default as cube } from \"./polyhedral/cube.js\";\nexport default function () {\n  var polygons = {\n    type: \"FeatureCollection\",\n    features: cube.map(function (face) {\n      face = face.slice();\n      face.push(face[0]);\n      return {\n        geometry: {\n          type: \"Polygon\",\n          coordinates: [face]\n        }\n      };\n    })\n  };\n  var parents = [-1, 0, 1, 5, 3, 2];\n  return voronoi().polygons(polygons).parents(parents).angle(0).scale(96.8737).center([135, -45]).rotate([120, 0]);\n}","/*\n * Cahill-Keyes projection\n *\n * Implemented in Perl by Mary Jo Graa (2011)\n *\n * Ported to D3.js by Enrico Spinielli (2013)\n *\n */\nimport { abs, cos, degrees, pi, radians, sin, sign, sqrt, tan } from \"./math.js\";\nimport { cartesianCross, cartesianDegrees, cartesianDot, sphericalDegrees } from \"./cartesian.js\";\nimport polyhedral from \"./polyhedral/index.js\";\nimport { geoProjectionMutator as projectionMutator } from \"d3-geo\";\nimport { solve2d } from \"./newton.js\";\nexport default function (faceProjection) {\n  faceProjection = faceProjection || function () {\n    return cahillKeyesProjection().scale(1);\n  };\n\n  var octahedron = [[0, 90], [-90, 0], [0, 0], [90, 0], [180, 0], [0, -90]];\n  octahedron = [[0, 2, 1], [0, 3, 2], [5, 1, 2], [5, 2, 3], [0, 1, 4], [0, 4, 3], [5, 4, 1], [5, 3, 4]].map(function (face) {\n    return face.map(function (i) {\n      return octahedron[i];\n    });\n  });\n  var ck = octahedron.map(function (face) {\n    var xyz = face.map(cartesianDegrees),\n        n = xyz.length,\n        a = xyz[n - 1],\n        b,\n        theta = 17 * radians,\n        cosTheta = cos(theta),\n        sinTheta = sin(theta),\n        hexagon = [];\n\n    for (var i = 0; i < n; ++i) {\n      b = xyz[i];\n      hexagon.push(sphericalDegrees([a[0] * cosTheta + b[0] * sinTheta, a[1] * cosTheta + b[1] * sinTheta, a[2] * cosTheta + b[2] * sinTheta]), sphericalDegrees([b[0] * cosTheta + a[0] * sinTheta, b[1] * cosTheta + a[1] * sinTheta, b[2] * cosTheta + a[2] * sinTheta]));\n      a = b;\n    }\n\n    return hexagon;\n  });\n  var cornerNormals = [];\n  var parents = [-1, 3, 0, 2, 0, 1, 4, 5];\n  ck.forEach(function (hexagon, j) {\n    var face = octahedron[j],\n        n = face.length,\n        normals = cornerNormals[j] = [];\n\n    for (var i = 0; i < n; ++i) {\n      ck.push([face[i], hexagon[(i * 2 + 2) % (2 * n)], hexagon[(i * 2 + 1) % (2 * n)]]);\n      parents.push(j);\n      normals.push(cartesianCross(cartesianDegrees(hexagon[(i * 2 + 2) % (2 * n)]), cartesianDegrees(hexagon[(i * 2 + 1) % (2 * n)])));\n    }\n  });\n  var faces = ck.map(function (face) {\n    return {\n      project: faceProjection(face),\n      face: face\n    };\n  });\n  parents.forEach(function (d, i) {\n    var parent = faces[d];\n    parent && (parent.children || (parent.children = [])).push(faces[i]);\n  });\n  return polyhedral(faces[0], face, 0, true).scale(0.023975).rotate([20, 0]).center([0, -17]);\n\n  function face(lambda, phi) {\n    var cosPhi = cos(phi),\n        p = [cosPhi * cos(lambda), cosPhi * sin(lambda), sin(phi)];\n    var hexagon = lambda < -pi / 2 ? phi < 0 ? 6 : 4 : lambda < 0 ? phi < 0 ? 2 : 0 : lambda < pi / 2 ? phi < 0 ? 3 : 1 : phi < 0 ? 7 : 5;\n    var n = cornerNormals[hexagon];\n    return faces[cartesianDot(n[0], p) < 0 ? 8 + 3 * hexagon : cartesianDot(n[1], p) < 0 ? 8 + 3 * hexagon + 1 : cartesianDot(n[2], p) < 0 ? 8 + 3 * hexagon + 2 : hexagon];\n  }\n} // all names of reference points, A, B, D, ... , G, P75\n// or zones, A-L, are detailed fully in Gene Keyes'\n// web site http://www.genekeyes.com/CKOG-OOo/7-CKOG-illus-&-coastline.html\n\nexport function cahillKeyesRaw(mg) {\n  var CK = {\n    lengthMG: mg // magic scaling length\n\n  };\n  preliminaries();\n\n  function preliminaries() {\n    var pointN, lengthMB, lengthMN, lengthNG, pointU;\n    var m = 29,\n        // meridian\n    p = 15,\n        // parallel\n    p73a,\n        lF,\n        lT,\n        lM,\n        l,\n        pointV,\n        k = sqrt(3);\n    CK.lengthMA = 940 / 10000 * CK.lengthMG;\n    CK.lengthParallel0to73At0 = CK.lengthMG / 100;\n    CK.lengthParallel73to90At0 = (CK.lengthMG - CK.lengthMA - CK.lengthParallel0to73At0 * 73) / (90 - 73);\n    CK.sin60 = k / 2; // 3/2 \n\n    CK.cos60 = 0.5;\n    CK.pointM = [0, 0];\n    CK.pointG = [CK.lengthMG, 0];\n    pointN = [CK.lengthMG, CK.lengthMG * tan(30 * radians)];\n    CK.pointA = [CK.lengthMA, 0];\n    CK.pointB = lineIntersection(CK.pointM, 30, CK.pointA, 45);\n    CK.lengthAG = distance(CK.pointA, CK.pointG);\n    CK.lengthAB = distance(CK.pointA, CK.pointB);\n    lengthMB = distance(CK.pointM, CK.pointB);\n    lengthMN = distance(CK.pointM, pointN);\n    lengthNG = distance(pointN, CK.pointG);\n    CK.pointD = interpolate(lengthMB, lengthMN, pointN, CK.pointM);\n    CK.pointF = [CK.lengthMG, lengthNG - lengthMB];\n    CK.pointE = [pointN[0] - CK.lengthMA * sin(30 * radians), pointN[1] - CK.lengthMA * cos(30 * radians)];\n    CK.lengthGF = distance(CK.pointG, CK.pointF);\n    CK.lengthBD = distance(CK.pointB, CK.pointD);\n    CK.lengthBDE = CK.lengthBD + CK.lengthAB; // lengthAB = lengthDE \n\n    CK.lengthGFE = CK.lengthGF + CK.lengthAB; // lengthAB = lengthFE \n\n    CK.deltaMEq = CK.lengthGFE / 45;\n    CK.lengthAP75 = (90 - 75) * CK.lengthParallel73to90At0;\n    CK.lengthAP73 = CK.lengthMG - CK.lengthMA - CK.lengthParallel0to73At0 * 73;\n    pointU = [CK.pointA[0] + CK.lengthAP73 * cos(30 * radians), CK.pointA[1] + CK.lengthAP73 * sin(30 * radians)];\n    CK.pointT = lineIntersection(pointU, -60, CK.pointB, 30);\n    p73a = parallel73(m);\n    lF = p73a.lengthParallel73;\n    lT = lengthTorridSegment(m);\n    lM = lengthMiddleSegment(m);\n    l = p * (lT + lM + lF) / 73;\n    pointV = [0, 0];\n    CK.pointC = [0, 0];\n    CK.radius = 0;\n    l = l - lT;\n    pointV = interpolate(l, lM, jointT(m), jointF(m));\n    CK.pointC[1] = (pointV[0] * pointV[0] + pointV[1] * pointV[1] - CK.pointD[0] * CK.pointD[0] - CK.pointD[1] * CK.pointD[1]) / (2 * (k * pointV[0] + pointV[1] - k * CK.pointD[0] - CK.pointD[1]));\n    CK.pointC[0] = k * CK.pointC[1];\n    CK.radius = distance(CK.pointC, CK.pointD);\n    return CK;\n  } //**** helper functions ****//\n  // distance between two 2D coordinates\n\n\n  function distance(p1, p2) {\n    var deltaX = p1[0] - p2[0],\n        deltaY = p1[1] - p2[1];\n    return sqrt(deltaX * deltaX + deltaY * deltaY);\n  } // return 2D point at position length/totallength of the line\n  // defined by two 2D points, start and end.\n\n\n  function interpolate(length, totalLength, start, end) {\n    var xy = [start[0] + (end[0] - start[0]) * length / totalLength, start[1] + (end[1] - start[1]) * length / totalLength];\n    return xy;\n  } // return the 2D point intersection between two lines defined\n  // by one 2D point and a slope each.\n\n\n  function lineIntersection(point1, slope1, point2, slope2) {\n    // s1/s2 = slope in degrees\n    var m1 = tan(slope1 * radians),\n        m2 = tan(slope2 * radians),\n        p = [0, 0];\n    p[0] = (m1 * point1[0] - m2 * point2[0] - point1[1] + point2[1]) / (m1 - m2);\n    p[1] = m1 * (p[0] - point1[0]) + point1[1];\n    return p;\n  } // return the 2D point intercepting a circumference centered\n  // at cc and of radius rn and a line defined by 2 points, p1 and p2:\n  // First element of the returned array is a flag to state whether there is\n  // an intersection, a value of zero (0) means NO INTERSECTION.\n  // The following array is the 2D point of the intersection.\n  // Equations from \"Intersection of a Line and a Sphere (or circle)/Line Segment\"\n  // at http://paulbourke.net/geometry/circlesphere/\n\n\n  function circleLineIntersection(cc, r, p1, p2) {\n    var x1 = p1[0],\n        y1 = p1[1],\n        x2 = p2[0],\n        y2 = p2[1],\n        xc = cc[0],\n        yc = cc[1],\n        a = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1),\n        b = 2 * ((x2 - x1) * (x1 - xc) + (y2 - y1) * (y1 - yc)),\n        c = xc * xc + yc * yc + x1 * x1 + y1 * y1 - 2 * (xc * x1 + yc * y1) - r * r,\n        d = b * b - 4 * a * c,\n        u1 = 0,\n        u2 = 0,\n        x = 0,\n        y = 0;\n\n    if (a === 0) {\n      return [0, [0, 0]];\n    } else if (d < 0) {\n      return [0, [0, 0]];\n    }\n\n    u1 = (-b + sqrt(d)) / (2 * a);\n    u2 = (-b - sqrt(d)) / (2 * a);\n\n    if (0 <= u1 && u1 <= 1) {\n      x = x1 + u1 * (x2 - x1);\n      y = y1 + u1 * (y2 - y1);\n      return [1, [x, y]];\n    } else if (0 <= u2 && u2 <= 1) {\n      x = x1 + u2 * (x2 - x1);\n      y = y1 + u2 * (y2 - y1);\n      return [1, [x, y]];\n    } else {\n      return [0, [0, 0]];\n    }\n  } // counterclockwise rotate 2D vector, xy, by angle (in degrees)\n  // [original CKOG uses clockwise rotation]\n\n\n  function rotate(xy, angle) {\n    var xynew = [0, 0];\n\n    if (angle === -60) {\n      xynew[0] = xy[0] * CK.cos60 + xy[1] * CK.sin60;\n      xynew[1] = -xy[0] * CK.sin60 + xy[1] * CK.cos60;\n    } else if (angle === -120) {\n      xynew[0] = -xy[0] * CK.cos60 + xy[1] * CK.sin60;\n      xynew[1] = -xy[0] * CK.sin60 - xy[1] * CK.cos60;\n    } else {\n      // !!!!! This should not happen for this projection!!!!\n      // the general algorith: cos(angle) * xy + sin(angle) * perpendicular(xy)\n      // return cos(angle * radians) * xy + sin(angle * radians) * perpendicular(xy);\n      //console.log(\"rotate: angle \" + angle + \" different than -60 or -120!\");\n      // counterclockwise\n      xynew[0] = xy[0] * cos(angle * radians) - xy[1] * sin(angle * radians);\n      xynew[1] = xy[0] * sin(angle * radians) + xy[1] * cos(angle * radians);\n    }\n\n    return xynew;\n  } // truncate towards zero like int() in Perl\n\n\n  function truncate(n) {\n    return Math[n > 0 ? \"floor\" : \"ceil\"](n);\n  }\n\n  function equator(m) {\n    var l = CK.deltaMEq * m,\n        jointE = [0, 0];\n\n    if (l <= CK.lengthGF) {\n      jointE = [CK.pointG[0], l];\n    } else {\n      l = l - CK.lengthGF;\n      jointE = interpolate(l, CK.lengthAB, CK.pointF, CK.pointE);\n    }\n\n    return jointE;\n  }\n\n  function jointE(m) {\n    return equator(m);\n  }\n\n  function jointT(m) {\n    return lineIntersection(CK.pointM, 2 * m / 3, jointE(m), m / 3);\n  }\n\n  function jointF(m) {\n    if (m === 0) {\n      return [CK.pointA + CK.lengthAB, 0];\n    }\n\n    var xy = lineIntersection(CK.pointA, m, CK.pointM, 2 * m / 3);\n    return xy;\n  }\n\n  function lengthTorridSegment(m) {\n    return distance(jointE(m), jointT(m));\n  }\n\n  function lengthMiddleSegment(m) {\n    return distance(jointT(m), jointF(m));\n  }\n\n  function parallel73(m) {\n    var p73 = [0, 0],\n        jF = jointF(m),\n        lF = 0,\n        xy = [0, 0];\n\n    if (m <= 30) {\n      p73[0] = CK.pointA[0] + CK.lengthAP73 * cos(m * radians);\n      p73[1] = CK.pointA[1] + CK.lengthAP73 * sin(m * radians);\n      lF = distance(jF, p73);\n    } else {\n      p73 = lineIntersection(CK.pointT, -60, jF, m);\n      lF = distance(jF, p73);\n\n      if (m > 44) {\n        xy = lineIntersection(CK.pointT, -60, jF, 2 / 3 * m);\n\n        if (xy[0] > p73[0]) {\n          p73 = xy;\n          lF = -distance(jF, p73);\n        }\n      }\n    }\n\n    return {\n      parallel73: p73,\n      lengthParallel73: lF\n    };\n  }\n\n  function parallel75(m) {\n    return [CK.pointA[0] + CK.lengthAP75 * cos(m * radians), CK.pointA[1] + CK.lengthAP75 * sin(m * radians)];\n  } // special functions to transform lon/lat to x/y\n\n\n  function ll2mp(lon, lat) {\n    var south = [0, 6, 7, 8, 5],\n        o = truncate((lon + 180) / 90 + 1),\n        p,\n        // parallel\n    m = (lon + 720) % 90 - 45,\n        // meridian\n    s = sign(m);\n    m = abs(m);\n    if (o === 5) o = 1;\n    if (lat < 0) o = south[o];\n    p = abs(lat);\n    return [m, p, s, o];\n  }\n\n  function zoneA(m, p) {\n    return [CK.pointA[0] + (90 - p) * 104, 0];\n  }\n\n  function zoneB(m, p) {\n    return [CK.pointG[0] - p * 100, 0];\n  }\n\n  function zoneC(m, p) {\n    var l = 104 * (90 - p);\n    return [CK.pointA[0] + l * cos(m * radians), CK.pointA[1] + l * sin(m * radians)];\n  }\n\n  function zoneD(m\n  /*, p */\n  ) {\n    // p = p; // just keep it for symmetry in signature\n    return equator(m);\n  }\n\n  function zoneE(m, p) {\n    var l = 1560 + (75 - p) * 100;\n    return [CK.pointA[0] + l * cos(m * radians), CK.pointA[1] + l * sin(m * radians)];\n  }\n\n  function zoneF(m, p) {\n    return interpolate(p, 15, CK.pointE, CK.pointD);\n  }\n\n  function zoneG(m, p) {\n    var l = p - 15;\n    return interpolate(l, 58, CK.pointD, CK.pointT);\n  }\n\n  function zoneH(m, p) {\n    var p75 = parallel75(45),\n        p73a = parallel73(m),\n        p73 = p73a.parallel73,\n        lF = distance(CK.pointT, CK.pointB),\n        lF75 = distance(CK.pointB, p75),\n        l = (75 - p) * (lF75 + lF) / 2,\n        xy = [0, 0];\n\n    if (l <= lF75) {\n      xy = interpolate(l, lF75, p75, CK.pointB);\n    } else {\n      l = l - lF75;\n      xy = interpolate(l, lF, CK.pointB, p73);\n    }\n\n    return xy;\n  }\n\n  function zoneI(m, p) {\n    var p73a = parallel73(m),\n        lT = lengthTorridSegment(m),\n        lM = lengthMiddleSegment(m),\n        l = p * (lT + lM + p73a.lengthParallel73) / 73,\n        xy;\n\n    if (l <= lT) {\n      xy = interpolate(l, lT, jointE(m), jointT(m));\n    } else if (l <= lT + lM) {\n      l = l - lT;\n      xy = interpolate(l, lM, jointT(m), jointF(m));\n    } else {\n      l = l - lT - lM;\n      xy = interpolate(l, p73a.lengthParallel73, jointF(m), p73a.parallel73);\n    }\n\n    return xy;\n  }\n\n  function zoneJ(m, p) {\n    var p75 = parallel75(m),\n        lF75 = distance(jointF(m), p75),\n        p73a = parallel73(m),\n        p73 = p73a.parallel73,\n        lF = p73a.lengthParallel73,\n        l = (75 - p) * (lF75 - lF) / 2,\n        xy = [0, 0];\n\n    if (l <= lF75) {\n      xy = interpolate(l, lF75, p75, jointF(m));\n    } else {\n      l = l - lF75;\n      xy = interpolate(l, -lF, jointF(m), p73);\n    }\n\n    return xy;\n  }\n\n  function zoneK(m, p, l15) {\n    var l = p * l15 / 15,\n        lT = lengthTorridSegment(m),\n        lM = lengthMiddleSegment(m),\n        xy = [0, 0];\n\n    if (l <= lT) {\n      // point is in torrid segment\n      xy = interpolate(l, lT, jointE(m), jointT(m));\n    } else {\n      // point is in middle segment\n      l = l - lT;\n      xy = interpolate(l, lM, jointT(m), jointF(m));\n    }\n\n    return xy;\n  }\n\n  function zoneL(m, p, l15) {\n    var p73a = parallel73(m),\n        p73 = p73a.parallel73,\n        lT = lengthTorridSegment(m),\n        lM = lengthMiddleSegment(m),\n        xy,\n        lF = p73a.lengthParallel73,\n        l = l15 + (p - 15) * (lT + lM + lF - l15) / 58;\n\n    if (l <= lT) {\n      //on torrid segment\n      xy = interpolate(l, lT, jointE(m), jointF(m));\n    } else if (l <= lT + lM) {\n      //on middle segment\n      l = l - lT;\n      xy = interpolate(l, lM, jointT(m), jointF(m));\n    } else {\n      //on frigid segment\n      l = l - lT - lM;\n      xy = interpolate(l, lF, jointF(m), p73);\n    }\n\n    return xy;\n  } // convert half-octant meridian,parallel to x,y coordinates.\n  // arguments are meridian, parallel\n\n\n  function mp2xy(m, p) {\n    var xy = [0, 0],\n        lT,\n        p15a,\n        p15,\n        flag15,\n        l15;\n\n    if (m === 0) {\n      // zones (a) and (b)\n      if (p >= 75) {\n        xy = zoneA(m, p);\n      } else {\n        xy = zoneB(m, p);\n      }\n    } else if (p >= 75) {\n      xy = zoneC(m, p);\n    } else if (p === 0) {\n      xy = zoneD(m, p);\n    } else if (p >= 73 && m <= 30) {\n      xy = zoneE(m, p);\n    } else if (m === 45) {\n      if (p <= 15) {\n        xy = zoneF(m, p);\n      } else if (p <= 73) {\n        xy = zoneG(m, p);\n      } else {\n        xy = zoneH(m, p);\n      }\n    } else {\n      if (m <= 29) {\n        xy = zoneI(m, p);\n      } else {\n        // supple zones (j), (k) and (l)\n        if (p >= 73) {\n          xy = zoneJ(m, p);\n        } else {\n          //zones (k) and (l)\n          p15a = circleLineIntersection(CK.pointC, CK.radius, jointT(m), jointF(m));\n          flag15 = p15a[0];\n          p15 = p15a[1];\n          lT = lengthTorridSegment(m);\n\n          if (flag15 === 1) {\n            // intersection is in middle segment\n            l15 = lT + distance(jointT(m), p15);\n          } else {\n            // intersection is in torrid segment\n            p15a = circleLineIntersection(CK.pointC, CK.radius, jointE(m), jointT(m));\n            flag15 = p15a[0];\n            p15 = p15a[1];\n\n            if (flag15 === 0) {//console.log(\"Something weird!\");\n              // TODO: Trap this! Something odd happened!\n            }\n\n            l15 = lT - distance(jointT(m), p15);\n          }\n\n          if (p <= 15) {\n            xy = zoneK(m, p, l15);\n          } else {\n            //zone (l)\n            xy = zoneL(m, p, l15);\n          }\n        }\n      }\n    }\n\n    return xy;\n  } // from half-octant to megamap (single rotated octant)\n\n\n  function mj2g(xy, octant) {\n    var xynew = [0, 0];\n\n    if (octant === 0) {\n      xynew = rotate(xy, -60);\n    } else if (octant === 1) {\n      xynew = rotate(xy, -120);\n      xynew[0] -= CK.lengthMG;\n    } else if (octant === 2) {\n      xynew = rotate(xy, -60);\n      xynew[0] -= CK.lengthMG;\n    } else if (octant === 3) {\n      xynew = rotate(xy, -120);\n      xynew[0] += CK.lengthMG;\n    } else if (octant === 4) {\n      xynew = rotate(xy, -60);\n      xynew[0] += CK.lengthMG;\n    } else if (octant === 5) {\n      xynew = rotate([2 * CK.lengthMG - xy[0], xy[1]], -60);\n      xynew[0] += CK.lengthMG;\n    } else if (octant === 6) {\n      xynew = rotate([2 * CK.lengthMG - xy[0], xy[1]], -120);\n      xynew[0] -= CK.lengthMG;\n    } else if (octant === 7) {\n      xynew = rotate([2 * CK.lengthMG - xy[0], xy[1]], -60);\n      xynew[0] -= CK.lengthMG;\n    } else if (octant === 8) {\n      xynew = rotate([2 * CK.lengthMG - xy[0], xy[1]], -120);\n      xynew[0] += CK.lengthMG;\n    } else {\n      // TODO trap this some way.\n      // ERROR!\n      // print \"Error converting to M-map coordinates; there is no Octant octant!\\n\";\n      //console.log(\"mj2g: something weird happened!\");\n      return xynew;\n    }\n\n    return xynew;\n  } // general CK map projection\n\n\n  function forward(lambda, phi) {\n    // lambda, phi are in radians.\n    var lon = lambda * degrees,\n        lat = phi * degrees,\n        res = ll2mp(lon, lat),\n        m = res[0],\n        // 0  m  45\n    p = res[1],\n        // 0  p  90\n    s = res[2],\n        // -1 / 1 = side of m\n    o = res[3],\n        // octant\n    xy = mp2xy(m, p),\n        mm = mj2g([xy[0], s * xy[1]], o);\n    return mm;\n  }\n\n  forward.invert = solve2d(forward);\n  return forward;\n}\n\nfunction cahillKeyesProjection() {\n  var mg = 10000,\n      m = projectionMutator(cahillKeyesRaw);\n  return m(mg);\n}","import _toConsumableArray from \"/Users/linying/codespace/Lyzzz-s-Blog/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\n\n/*\n * Complex logarithm projection\n *\n * Based on the following papers by Joachim Bttger et al.:\n * - DetailInContext Visualization for Satellite Imagery (2008) (https://doi.org/10.1111/j.1467-8659.2008.01156.x)\n * - Complex Logarithmic Views for Small Details in Large Contexts (2006) (https://doi.org/10.1109/TVCG.2006.126)\n *\n * Implemented for d3 by Matthias Albrecht and Jochen Grtler (2019)\n *\n */\nimport { geoProjectionMutator as projectionMutator, geoAzimuthalEqualAreaRaw as azimuthalEqualAreaRaw } from \"d3-geo\";\nimport { abs, sin, cos, pi, exp, atan2 } from \"./math.js\";\nimport { complexMul, complexLogHypot } from \"./complex.js\";\nimport { default as clipPolygon } from \"./clip/polygon.js\"; // Default planar projection and cutoff latitude, see below for an explanation of these settings.\n\nvar DEFAULT_PLANAR_PROJECTION_RAW = azimuthalEqualAreaRaw;\nvar DEFAULT_CUTOFF_LATITUDE = -0.05; // Offset used to prevent logarithm of 0.\n\nvar CARTESIAN_OFFSET = 1e-10; // Projection parameters for the default 960x500 projection area.\n\nvar DEFAULT_PROJECTION_PARAMS = {\n  angle: 90,\n  center: [0, 5.022570623227068],\n  scale: 79.92959180396787,\n  translate: [479.9999905630355, 250.35977064160338]\n}; // Vertices of the clipping polygon in spherical coordinates.\n// It contains the whole world except a small strip along longitude 0/180 crossing the south pole.\n\nvar CLIP_POLY_SPHERICAL = [[-180, -1e-4], [180, -1e-4], [1e-4, DEFAULT_CUTOFF_LATITUDE], [-1e-4, DEFAULT_CUTOFF_LATITUDE]]; // Clipping polygon precision.\n\nvar N_SIDE = 5;\nvar N_BOTTOM = 50;\nexport function complexLogRaw() {\n  var planarProjectionRaw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_PLANAR_PROJECTION_RAW;\n\n  function forward(lambda, phi) {\n    // Project on plane.\n    // Interpret projected point on complex plane.\n    var aziComp = planarProjectionRaw(lambda, phi); // Rotate by -90 degrees in complex plane so the following complex log projection will be horizontally centered\n\n    aziComp = complexMul(aziComp, [cos(-pi / 2), sin(-pi / 2)]); // Small offset to prevent logarithm of 0.\n\n    if (aziComp[0] == 0 && aziComp[1] == 0) {\n      aziComp[0] += CARTESIAN_OFFSET;\n      aziComp[1] += CARTESIAN_OFFSET;\n    } // Apply complex logarithm.\n\n\n    var logComp = [complexLogHypot(aziComp[0], aziComp[1]), atan2(aziComp[1], aziComp[0])];\n    return logComp;\n  }\n\n  function invert(x, y) {\n    // Inverse complex logarithm (complex exponential function).\n    var invLogComp = [exp(x) * cos(y), exp(x) * sin(y)]; // Undo rotation.\n\n    invLogComp = complexMul(invLogComp, [cos(pi / 2), sin(pi / 2)]); // Invert azimuthal equal area.\n\n    return planarProjectionRaw.invert(invLogComp[0], invLogComp[1]);\n  }\n\n  forward.invert = invert;\n  return forward;\n}\nexport default function () {\n  var planarProjectionRaw = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_PLANAR_PROJECTION_RAW;\n  var cutoffLatitude = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_CUTOFF_LATITUDE;\n  var mutator = projectionMutator(complexLogRaw);\n  var projection = mutator(planarProjectionRaw); // Projection used to project onto the complex plane.\n\n  projection.planarProjectionRaw = function (_) {\n    return arguments.length ? clipped(mutator(planarProjectionRaw = _)) : planarProjectionRaw;\n  }; // Latitude relative to the projection center at which to cutoff/clip the projection, lower values result in more detail around the projection center.\n  // Value must be < 0 because complex log projects the origin to infinity.\n\n\n  projection.cutoffLatitude = function (_) {\n    return arguments.length ? (cutoffLatitude = _, clipped(mutator(planarProjectionRaw))) : cutoffLatitude;\n  };\n\n  function clipped(projection) {\n    var angle = projection.angle();\n    var scale = projection.scale();\n    var center = projection.center();\n    var translate = projection.translate();\n    var rotate = projection.rotate();\n    projection.angle(DEFAULT_PROJECTION_PARAMS.angle).scale(1).center([0, 0]).rotate([0, 0]).translate([0, 0]).preclip(); // These are corner vertices of a rectangle in the projected complex log view.\n\n    var topLeft = projection(CLIP_POLY_SPHERICAL[0]);\n    var topRight = projection(CLIP_POLY_SPHERICAL[1]);\n    var bottomRight = projection([CLIP_POLY_SPHERICAL[2][0], cutoffLatitude]);\n    var bottomLeft = projection([CLIP_POLY_SPHERICAL[3][0], cutoffLatitude]);\n    var width = abs(topRight[0] - topLeft[0]);\n    var height = abs(bottomRight[1] - topRight[1]); // Prevent overlapping polygons that result from paths that go from one side to the other, \n    // so cut along 180/-180 degree line (left and right in complex log projected view).\n    // This means cutting against a rectangular shaped polygon in the projected view.\n    // The following generator produces a polygon that is shaped like this:\n    //\n    // Winding order: ==>\n    //\n    // ******************|\n    // |                 |   \n    // |                 |                        \n    // |                 |                        \n    // |                 |                       \n    // |                 |                         \n    // |------------------ \n    //\n    // N_SIDE determines how many vertices to insert along the sides (marked as | above).\n    // N_BOTTOM determines how many vertices to insert along the bottom (marked as - above).\n    //\n    // The resulting polygon vertices are back-projected to spherical coordinates.\n\n    var polygon = {\n      type: \"Polygon\",\n      coordinates: [[topLeft].concat(_toConsumableArray(Array.from({\n        length: N_SIDE\n      }, function (_, t) {\n        return [bottomRight[0], bottomRight[1] - height * (N_SIDE - t) / N_SIDE];\n      })), _toConsumableArray(Array.from({\n        length: N_BOTTOM\n      }, function (_, t) {\n        return [bottomRight[0] - width * t / N_BOTTOM, bottomRight[1]];\n      })), _toConsumableArray(Array.from({\n        length: N_SIDE\n      }, function (_, t) {\n        return [bottomLeft[0], bottomLeft[1] - height * t / N_SIDE];\n      })), [topLeft]).map(function (point) {\n        return projection.invert(point);\n      })]\n    };\n    return projection.angle(angle).scale(scale).center(center).translate(translate).rotate(rotate).preclip(clipPolygon(polygon));\n  } // The following values are for the default 960x500 projection area\n\n\n  return clipped(projection).angle(DEFAULT_PROJECTION_PARAMS.angle).center(DEFAULT_PROJECTION_PARAMS.center).scale(DEFAULT_PROJECTION_PARAMS.scale).translate(DEFAULT_PROJECTION_PARAMS.translate);\n}","export { default as geoClipPolygon } from \"./clip/polygon\";\nexport { default as geoIntersectArc } from \"./intersect\";\nexport { default as geoPolyhedral } from \"./polyhedral/index\";\nexport { default as geoPolyhedralButterfly } from \"./polyhedral/butterfly\";\nexport { default as geoPolyhedralCollignon } from \"./polyhedral/collignon\";\nexport { default as geoPolyhedralWaterman } from \"./polyhedral/waterman\";\nexport { default as geoPolyhedralVoronoi } from \"./polyhedral/voronoi\";\nexport { default as geoDodecahedral } from \"./polyhedral/dodecahedral\";\nexport { default as geoCox, coxRaw as geoCoxRaw } from \"./cox.js\";\nexport { default as geoTetrahedralLee, leeRaw as geoLeeRaw } from \"./tetrahedralLee.js\";\nexport { default as geoGrayFullerRaw } from \"./grayfuller\";\nexport { default as geoAirocean } from \"./airocean\";\nexport { default as geoIcosahedral } from \"./icosahedral\";\nexport { default as geoImago, imagoBlock as geoImagoBlock, imagoRaw as geoImagoRaw } from \"./imago\";\nexport { default as geoCubic } from \"./cubic\";\nexport { default as geoCahillKeyes, cahillKeyesRaw as geoCahillKeyesRaw } from \"./cahillKeyes\";\nexport { default as geoComplexLog, complexLogRaw as geoComplexLogRaw } from \"./complexLog\";","import React, { Component } from 'react';\nimport memoizeOne from 'memoize-one';\nimport { CacheProvider } from '@emotion/core';\nimport 'react-dom';\nimport 'prop-types';\nimport './utils-06b0d5a4.browser.esm.js';\nexport { y as components } from './index-4322c0ed.browser.esm.js';\nimport { S as Select } from './Select-9fdb8cd0.browser.esm.js';\nexport { c as createFilter, a as defaultTheme, m as mergeStyles } from './Select-9fdb8cd0.browser.esm.js';\nimport '@emotion/css';\nimport 'react-input-autosize';\nimport { m as manageState } from './stateManager-04f734a2.browser.esm.js';\nimport createCache from '@emotion/cache';\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar NonceProvider = /*#__PURE__*/function (_Component) {\n  _inheritsLoose(NonceProvider, _Component);\n\n  function NonceProvider(props) {\n    var _this;\n\n    _this = _Component.call(this, props) || this;\n\n    _this.createEmotionCache = function (nonce) {\n      return createCache({\n        nonce: nonce\n      });\n    };\n\n    _this.createEmotionCache = memoizeOne(_this.createEmotionCache);\n    return _this;\n  }\n\n  var _proto = NonceProvider.prototype;\n\n  _proto.render = function render() {\n    var emotionCache = this.createEmotionCache(this.props.nonce);\n    return React.createElement(CacheProvider, {\n      value: emotionCache\n    }, this.props.children);\n  };\n\n  return NonceProvider;\n}(Component);\n\nvar index = manageState(Select);\nexport default index;\nexport { NonceProvider };"],"sourceRoot":""}